<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>
//  继承:
//  原型继承:用来继承共有的属性(共有的属性基本上都写在原型上,而我们原型继承就是把写在原型上的属性,继承下来)
//  function Person(){
//
//  }
//
//  Person.prototype.say = function(){
//    console.log(1);
//  }
//
//  function Student(){
//
//  }
//
////  Student.prototype = new Person();
//  Student.prototype = Person.prototype;
//  var s = new Student();
//  s.say();
  
//    Function的原型问题:
//    Function自己创造了自己
//    Object是Function的实例
//    不管是谁,原型链最终一定是指向了Object的原型在往上就是null
  
  
//      js是一门单线程的语言
//      单线程的特点: 一个只能做一件事,做完一件事,才能做下一件事
//        堆: 存储引用数据类型
//        栈: 存储基本数据类型, 变量也会在栈里.  所有代码执行的时候,都是要加载到栈中
  
//        事件轮询机制:
//        v8引擎 : 执行js代码的地方(堆,栈)
//        webapi : 帮助js计时
//        事件轮询: 会一直观察栈和任务队列,并且会把任务对列中的任务拿到栈中执行
//        任务队列: 存储定时器事件到了之后/触发了之后的事件处理函数.
//
//            执行过程: 比如说,注册事件,设置定时器,当在栈中,执行了这些代码.定时器计时的工作,获取是存储事件的工作就交给了浏览器. 当定时器的事件到了之后/事件被触发了. 浏览器会把定时器的回调函数/事件处理函数存放到任务队列中等待执行.当栈里面的代码执行完毕了.事件轮询会将任务队列中的第一个任务,拿到栈中执行.任务队列会一直重复刚才的动作.
  
//          闭包:
//          mdn: 函数和函数的作用域的结合
//          自己理解: 内部函数引用了外部函数的变量,那么外部函数形成了一个闭包
//          闭包的作用:
//          1. 私有化数据
//          2. 私有化的基础上保持数据
//          闭包的缺点:
//          由于内部函数,引用了外部函数的变量,导致外部函数无法出栈,有可能会导致栈溢出
  
</script>
</body>
</html>