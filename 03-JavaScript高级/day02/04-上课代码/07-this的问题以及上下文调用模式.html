<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    // 在函数中this指向谁:
    // ★★★ 函数中的this指向谁,是由函数被调用的那一刻才确定下来的


    // 想要判断 ★函数中 的this指向谁,遵循两条原则:  (★★★ this是函数中的关键字)
    // 1. 我们要判断的this在哪个函数中
    // 2. 这个函数是哪种调用模式调用的 调用模式分为以下6种

    // 同一个函数的this在不同的调用模式下,this的指向会有所不同。所以要根据上面2点 根据具体情况判断函数中的this到底指向谁

    // function fn(){
    //     console.log(this);
    // }

    // 1 普通函数调用://函数中this --> window
    // fn(); 

    // 2 对象 (函数、数组(包括伪数组)也是对象) 调用 只要是 对象.函数名() 就是对象调用模式, 函数中this -->obj        哪个对象调用this所在的函数,this就指向这个对象
    // var obj = {};
    // obj.f = fn;
    // obj.f();  //this -->obj

    // 3 new 调用函数 函数中this --> 新创建出来的实例对象
    // var f = new fn();

    // 4 注册事件  函数中this --> box      当前执行的事件处理函数是哪个元素注册的,this就是这个元素 
    // box.onclick = fn;

    // 5 定时器  函数中this --> window
    // setInterval(fn,1000);


    // 6 上下文调用模式: 其实就是js中提供给我们的三个方法.而这三个方法的作用就是随意控制函数中this的指向
    
    // call
    // 函数.call(第一个参数:想让函数中this指向谁,就传谁进来, 
    // 后面的参数:本身调用函数需要传递实参,需要几个实参,就一个一个的传递即可);
    // call的作用: 1. 调用函数,并获得返回值 2.指定函数中this指向
    //                哪个函数.call,就调用这个函数 只不过函数中的this被指定了

    // apply
    // 函数.apply(第一个参数:想让函数中this指向谁,就传谁进来, 
    // 第二个参数:要求传入一个数组,数组中包含了函数需要的实参)
    // apply的作用: 1. 调用函数,并获得返回值 2, 指定函数中this的指向 
    //                 哪个函数.apply,就调用这个函数 只不过函数中的this被指定了

    // call和apply实际上都是调用函数,获得返回值,只不过把原来函数中的this指定了,即可以自定义函数中的this指向谁

    // ★★★ 注意: 函数只有通过.call 或 .apply 调用函数, 才能随意指定this.  函数本身的调用 即 函数名()  this的指向还是以原来this指向为准

    //   bind
    // 函数.bind(第一个参数:想让函数中this指向谁,就传谁进来,
    // 后面的参数:本身函数需要传递实参,需要几个实参,就一个一个的传递即可)
    // bind的作用: 1. 克隆 当前函数 (包括函数体 形参都克隆),返回克隆出来的新的函数(的地址)  ★不会调用函数
    //             2. 新克隆出来的函数,这个函数的this被指定了,其他不变
    // ★★★ bind只是克隆函数 不会调用函数  返回新克隆出来的函数(地址)
    // ★★★ 注意: 通过bind,返回的新的函数this被指定,之后无论在何处使用和调用这个返回的新的函数时,this永远都指向bind时指定的那个this (除了new 之外)
    // ★★★ 注意: bind方法 第一个参数之后的参数,即本身函数需要传递的实参,如果在bind时传了,则新克隆出来的函数实参也被指定了,如果不传,可以在调用克隆出来的函数时传
    //            所以我们一般用bind克隆函数的时候,只传第一个参数指定this,后面的函数的实参不传,在调用的时候再传
    // ★★★ 特殊: 当new 和 bind返回的函数一起使用的时候,函数中this指向的还是new新创建出来的对象 (实例)
    
    // 匿名函数使用this上下文  function() {}.call  /   function() {}.apply  /  function() {}.bind

    function fn(x, y){
        console.log(this);
        console.log(x + y);
    }

    // fn.call([1,3,4], 5, 8);
    // fn.apply({o:1}, [12,13]);  
    // var f = fn.bind({a:1},3,5); // 新克隆函数f的实参也被指定了,后续调用f传的实参无效
    var f = fn.bind({a:1}); // 新克隆函数f的实参没有被指定,后续调用f传入实参有效
    console.log(f);
    f(4,5);


    // 上下文调用模式的三个方法的总结: 
    // call, apply   这两个方法都会调用函数
    // call, bind   这两个方法,后面的传参方式是一样的
    // bind方法不会调用函数,只会克隆一个新的函数出来,这个新的函数中this已经被指定了
    // bind方法 第一个参数之后的参数,即本身函数需要传递的实参,如果在bind时传了,则新克隆出来的函数实参也被指定了,如果不传,可以在调用克隆出来的函数时传
    // apply方法第二个参数,要求传入一个数组,这个数组中包含函数需要的实参


    // ★★★ 注意: 函数只有通过.call 或 .apply 调用函数, 才能随意指定this.  函数本身的调用 即 函数名()  this的指向还是以原来this指向为准
    // ★★★ 注意: 通过bind,返回的新的函数this被指定,之后调用这个返回的新的函数时,this永远都指向bind时指定的那个this (除了new 之外)
    // ★★★ 特殊: 当new 和 bind返回的函数一起使用的时候,函数中this指向的还是new新创建出来的对象 (实例)
    


    </script>
</body>
</html>