<!--
 * @Author: Ling Hui Shi
 * @Date: 2020-02-16 19:54:47
 * @LastEditors: Ling Hui Shi
 * @LastEditTime: 2020-04-20 01:16:42
 * @Description: 
 -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>
  var a = 1;
  function fn(){
//    var a = 2;
    console.log(a);
  }




  //词法作用域(静态作用域)(变量查找规则): 代码一旦书写完毕,那么作用域就形成了,跟调用函数没有关系
  // js中所有变量, 数据(只要涉及到变量, 数据) 的访问/查找/使用/赋值等所有使用到变量的操作, 都需要遵循词法作用域的规则查找变量
//  1. 外部作用域不能访问内容作用域的变量, 内部可以访问外部
//  2. 访问/查找/使用/操作/赋值变量 等 的时候,先在自己的当前作用域中查找, 找到了直接使用(可以获取值, 也可以赋值),并停止查找 如果找不到就沿着作用域链往上级链找,找到了直接使用(可以获取值, 也可以赋值),并且停止查找,找不到就继续沿着作用域链往上找 (只能往上找,不能往下找, 也不能在同级链中找),直到全局作用域, 如果在全局中找到了就直接使用, 并停止查找, 若在全局中也没有找到, 则参考以下.
//  3. 延续2. 如果只是访问变量,如果找到全局都没有的话,会报错(xxx is not  defined)
//  4. 延续2. 如果要给变量赋值, 在自己作用域或沿着作用域链找到了, 则直接给变量赋值, 并停止查找, 若找到全局都没有的话,那么浏览器会帮我们在全局自动创建这个变量并赋值 (隐式全局)
//  5. ★ js中给变量赋值之前/变量访问, 获取, 使用, 操作 等 之前,要先通过词法作用域规则 ★ 先找到变量 ★ , ★并且找到的是执行代码这一时刻, 内存中变量存储的数据★, 然后才对变量进行赋值或访问, 获取, 使用, 操作 等.
//  6. 代码执行之前,要考虑预解析规则,函数的代码执行之前,也要执行预解析规则
//  ps: 词法作用域和作用域链 是查找 变量 的规则
//  ★: 访问和使用变量, 除了参考词法作用域, 还要参考 预解析 和 代码的执行顺序, 来看当前访问的变量是否声明及当前访问变量的值是多少
//  ★: 作用域只是访问变量的规则 不是访问数据的规则  比如将沙箱里的函数暴露到全局 全局只要有这个函数地址的变量 就可以调用函数 比如将沙箱里的引用变量暴露到全局 全局有这个引用地址的变量 就可以操作和访问地址里的数据了

// ★★★ 词法作用域查找数据, 都是以当前执行代码这一时刻, 内存中存储着的数据来进行查找的, 以当前执行代码这一时刻, 内存中此刻存储的数据为准

  // 根据词法作用域访问变量, 一个变量可以被访问/获取/使用/赋值 多次!!!

  // 作用域链:在js中, ★ 函数 会构成一个局部作用域, 全局中有函数,全局的是0级链,全局中的函数构成1级链, 函数中如果再有函数就是2级链,这样的一个关系,就是作用域链
  // 同级链中函数只能访问自身的局部变量 无法访问和使用同级链中其他函数中的局部变量
  // 作为参数的函数 作用域链的级数 与 函数调用处同级
  // ★★★ 调用函数时候， 函数体中访问/使用/操作变量先在自身函数作用域内查找, 若找到则直接使用, 并停止查找, 若没找到, 则从函数的声明 所在处开始, 沿着作用域链往上级链查找, 后面同词法作用域2.3.4点！！
</script>

<!-- 一个html中可以写多个script标签,他们都是同一个全局作用域 , 也可以引入多个js文件, 与引入的js文件也是同一个全局作用域, 多个引入的js文件之间也是同一个全局作用域 与script标签也是同一个全局作用域。都在同一个全局作用域 共享同一个全局作用域 数据互通, 数据共享, 会相互影响 -->
<!-- 一个页面的多个script标签,和引入的多个js文件, 都是在当前引入文件的页面全局作用域执行(它们(script标签或引入js文件)获取的dom元素或jq对象等, 都是从当前引入js的页面上获取的), 他们都是同一个全局作用域,所以数据互通, 数据共用, 相互影响, 都可以获取、操作、和使用, 声明、 赋值等, 遵循作用域规则, 共同作用于同一个作用域 -->
<!--  一个页面的多个script标签,和引入的多个js文件都会按照顺序从上到下进行解析和执行 -->
<!-- 直接在script标签内写js代码, 则不会请求资源, 可以直接执行, 若是通过script标签的src引入js文件, 则会先发起请求, 获取js文件中的所有内容, 然后将js文件中的所有内容当作js代码在当前引入页面的全局作用域执行 -->
<!-- ★ 页面中script标签内js代码和引入的.js文件中js代码, 都是从上往下同步解析和执行的, 要等到上一个script标签的(若是引入.js文件的, 要等到js文件请求完毕并.js文件中的js代码同步执行完毕后, 若请求是404则直接跳过, 直接同步解析执行下一个script标签)js代码同步执行完毕后, 才会继续往下同步解析和执行下一个script标签的js代码  -->
<!-- ★ 页面中多个script或引入的多个.js文件, 都是从上往下 同步解析 和执行js代码的 -->
<!-- 因为一个页面的多个script标签 和 引入的多个js文件共享同一个全局作用域, 且是同步执行, 要等到前面的执行完毕后, 才执行后面的, 所以 在各自script标签之前或引入js文件之前 引入的插件, 是可以共享使用插件功能的, 在各自js运行环境都可以使用 -->
<!-- 一个页面只有一个js全局作用域, 页面中的多个script标签, 以及引入的多个js文件, 共享这一个全局作用域 -->
<!-- ps: js运行环境中不能在引入其他js文件, 即script标签内 以及 .js文件里, 不能引入其他js文件 -->
<!-- ★★★ 页面中多个script标签, 和引入的多个js文件, js代码作用的是同一个页面(标签元素), 因为本质上是在当前页面引入js文件, 去请求js的, 所以执行js文件里的js代码也在当前页面 -->
<!-- 注意: 一个页面的多个script标签和引入的多个js文件, 虽然共享一个全局作用域, 数据互通, 数据共用, 都可以获取、操作、和使用
          但是他们的预解析是独立的, 各个script标签, 和 各个引入的js文件, 他们的预解析是独立进行的,
          浏览器从上到下解析执行, 碰到一个引入的js文件, 先会预解析这个js文件里的js代码, 然后再一行一行进行代码的解析和执行, 执行完后会到引入的js文件处, 继续往下解析执行
          如果碰到script标签, 就会先预解析这个script标签内的所有代码, 然后再一行一行进行解析和执行, 执行结束后继续往下执行js文件或script标签里的代码

     由于各自预解析的独立的, 所以一个引入多个js文件和书写多个script标签时候, 要考虑书写顺序.
-->
<!-- 注意: 一个页面的多个script标签和引入的多个js文件, 浏览器都会按照顺序进行解析和执行, 并且会进行数据保持, 将数据都存储在浏览器的内存里, 他们共享一个全局作用域, 数据互通, 数据共用, 都可以获取、操作、和使用,  -->
<!-- ★★★ 页面通过script标签引入js文件, 是同步加载请求和执行的, 即要等待上一个js文件全部同步加载请求和执行完毕(执行完毕) (若请求404则直接跳过), 页面才会继续往下执行后面的代码
           引入js文件的执行作用域和页面共享同一个全局作用域

      注意: js环境中, 如script标签内, .js文件中, 不能再引入js文件了.

      注意: 页面中的script标签和引入的多个js文件, 都是按顺序从上往下执行, 且是同步执行的, 全部执行完前面的才会接着执行后面的

      注意: ★★★ 引入js文件, js文件中若有涉及到相对路径的, 相对路径的出发点是从引入js文件的这个页面文件开始
-->
<script> a = 10</script>
<script> console.log(a); //10
    fn(); //10
 </script>
</body>
</html>
