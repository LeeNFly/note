<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>
//  1. 变量: 存储数据
//  申明: var 变量名;
//  变量名的命名规范: 合法的字符,包含数字,字母,下划线,$. 不能以数字开头,不能用关键字和保留字
//  赋值: 变量名 = 值;

//    声明和赋值合并:  var 变量名 = 值;
//    声明多个变量并且赋值合并:  var 变量名 = 值, 变量名 = 值, ..;
//                             var 变量名1 = 变量名2 = 变量名3 = .. = 值;

//      var 变量名 = 值, 变量名 = 值, ..;
//      var 变量名 = 值;
//      var 变量名 = 值;
//      var 变量名 = 值;
//
//      var 变量名1 = 变量名2 = 变量名3 = .. = 值;
//      var 变量名1 = 值;
//      变量名2 = 值;

//      如何存储数据: 存储基本数据类型存储的是值, 存储引用数据类型存储的是地址

//  2. 数据类型:
//      数字  整数,浮点数
//      字符串  '' ""
//      布尔   false true
//      null
//      undefined
//      对象  {},  数组,  函数, 元素, 伪数组

//  3. 操作符:
//    && || ! +

//      1 && 2  // 2
//      1 && 0  // 0
//      0 && 2  // 0  第一个值已经是false了,后面的就不需要再看了,这个就是短路

//        1 || 2  // 1
//        1 || 0  // 1
//        0 || 2  // 2
//        0 || ''  // ''

//        !1 // false
//        !!1 // true

//          + 什么时候是加的逻辑,什么时候是拼接字符串:
//         1. 如果 + 号只有一个操作数,那么就是把这个操作数转换成数字类型
//         2. 如果 + 号 有两个操作数,并且其中一个是字符串,那么就一定是拼接字符串


//  4.数据类型的转换
//    其他类型转字符串:
//      String(其他类型);
//      其他类型.toString();
//      + 拼接字符串
//    其他类型转数字:
//        Number()
//            1. 可以转除字符串外的其他数据类型
//            2. 如果字符串中有非数字类型,那么转的是NaN
//        parseInt()
//
//        parseFloat()

//          parse系列的相同点:
//           1. 只能把字符串类型转换成数字类型
//           2. 如果字符串中有非数字字符,根据非数字字符的位置去转换
//              '123a456'  -- > 123
//              'a123'  -- > NaN
//            parse系列的不同点:
//              parseInt() 转换成整数
//              parseFloat() 可以转换成浮点数
//        +

//        其他类型转布尔:
//          Boolean(其他类型)
//          !!

//          字符换转布尔: 空字符串是false, 其他都是true
//          数字转布尔: 0是false, NaN是false, 其他都是true
//          null转布尔 : false
//          undefined转布尔: false
//          对象转布尔: true

//
//    5. 流程控制
//      顺序结构
////    分支结构 : switch里面用的是全等
//      循环结构 : for while do..while for..in
//        var i = 0;
//        while(i < 100){
//          console.log('haha');
//          i++;
//        }
//
//
//        for(;true ; ){
//          if(){
//            break;
//          }
//        }

//  6. 数组: 存储数据(有序的存储方式)
//      创建数组:
//        var arr = new Array();
//        var arr = [];

//      获取数组里面的元素:
//          数组[下标]
//      添加元素:
//          数组[下标] = 值;
//          push()

//        数组常用的方法: (伪数组不能使用数组的所有方法)
//            数组.concat(另外一个数组) 把两个数组合并成一个
////            join() 把数组转换成字符串
////            slice(开始的下标, 结束的小标) 包含头,不包含尾 返回一个新的数组 原来的数组没有发生变化
////            splice(开始的下标, 截取的长度) 返回一个新的数组,原来的数组发生了变化
////              push() 从后面加
////              pop()从后面删除
////              shift() 从前面删
////              unshift() 从前面加  数组都发生变化了
////              forEach(function(item, index, arr){// 按照数组中下标从0开始 从小到大的顺序依次 遍历数组中每个元素, 每个元素都调用执行一次该函数}) 专门用来遍历数组  , 参数按照顺序,
//                  遍历数组, 数组中每个元素都调用同步执行一次该函数体代码, 且要等到上一个元素遍历同步执行完函数体之后, 才会遍历下一个元素
//                  遍历完数组中所有元素后(不会重复遍历, 每个元素只会遍历一次, 即每个元素只会调用一次该函数), 会自动结束遍历.
//                  遍历数组是同步★执行的, 即要等到数组中元素全部遍历结束之后, 才会继续往下执行遍历数组之后的代码
//                  遍历数组中元素, 调用函数时遇到函数return 只会终止当前遍历的这个元素的函数调用, 直接遍历下一个元素并调用函数, 不会终止数组的遍历

////                第一个参数: 数组中的每一项, 当前遍历数组中的元素(数组中的元素可以是任意类型), 当前遍历的数组中的元素值是什么, item就是什么, 相当于把数组中的每一项依次赋值给item进行遍历 ★ 赋的是值而非变量
////                第二个参数: 每一项对应的下标 (0开始, 从小到大), 是数字类型
////                第三个参数: 数组本身
//                  参数按照顺序一一对应接收, 需要占位符, 对于后面不需要的参数, 可以选择不接收. 比如不要arr, 则形参写 item, index 即可, 比如不要index, 形参写item即可,
//                  如果数组没有元素, 即是一个空数组, 则forEach不会进行遍历, 也不会报错.
//                  如果元素是引用类型的, 可以对引用类型进行获取和赋值操作, 操作和修改的是引用类型指向的那块地址里的数据, 由于是引用类型, 指向同一个地址, 则数组中对应的元素对应的引用地址里的数据也会改变
//                  ★ 若多个引用变量指向同一个引用地址,只要某一个引用变量对引用地址里的任意类型数据做出改变,因为指向的是同一个地址,同一份数据,则所有指向同一个地址的引用变量的属性也会发生改变 (再访问数据时对应的值也会发生改变,因为所指地址中的数据已经发生改变了).

//                   ps: 只要变量存储的是引用地址 就可以访问和使用地址里的数据 与地址里的数据在哪里存储 在哪个作用域存储 无关

//                  ps: 用querySelectorAll获取元素的伪数组, 可以使用forEach方法, 因为这个api是h5新增的, 内部帮我们实现了forEach方法

// forEach遍历原理: 
//  遍历数组的顺序都是按照数组中索引号从小到大进行遍历
//  每个元素都调用一次此函数, 其原理就是将数组中每个元素的值 和 索引 依次 赋值 给 item 和 index, 然后执行函数体, 注意, ★ 赋的是值而非变量
//  如果是赋基本数据类型的值, 则赋值前后互不影响, 在回调函数中对item进行赋值, 也不会改变数组中原来的元素的值的
//  如果赋的是引用数据类型, 则在回调函数中若item对引用地址里的数据做出修改, 则原数组中对应元素也会发生改变. 若不是对引用地址里的数据修改, 而是给item赋新的值, 则不会改变原数组中的数据
//  根据以上原理, 自行判断在使用数组API时, 是否会改变原来的数组, 这个是不确定的, 是灵活的, 具体要看怎么用

////               filter(function(item, index, arr){}) 过滤器 返回过滤后的数组  不改变原数组
////               every(function(item, index, arr){}) 如果数组中每一项都符合要求就返回true,否则返回false
////               some(function(item, index, arr){})  如果数组中有一项符合要求就返回true,都不符合才返回false
//                 find(function(v, i) {}) 遍历数组, 没有元素调用执行一次回调函数, 当函数返回true时, 停止遍历数组, 并返回当前遍历的这个元素. 即find方法是找数组重满足条件的第一个元素
//              var arr = [11,10,9];
//              var result = arr.every(function(item){
//                  return item >= 12;
//              });

            var result = arr.some(function(item){
              return item >= 12;
            });

              console.log(result);



//          var arr = ['a','b','c','d', 'a', 'b','d','a','e'];

//            var flag = true;
//            for(var i = 0; i < arr.length; i++){
//              if(arr[i] < 12){
//                flag = false;
//              }
//            }
//            console.log(flag);
//
//          var result = arr.filter(function(item){
//            return item === 'a';  // ['a','a','a']
//          });
//
//          console.log(result);

//          var newArr = [];
//          for(var i = 0; i < arr.length; i++) {
//            if(arr[i] === 'a'){
//              newArr.push(arr[i])
//            }
//          }
//        console.log(newArr);

//          arr.forEach(function(item, index){
//           console.log(index);
//          })
//          console.log(arr.join());
//          console.log(arr.join('-'));

//        console.log(arr.slice(0, 2)); //a,b
//        console.log(arr.slice(1, 2)); //b
//        console.log(arr);

//          console.log(arr.splice(0, 3));
//          console.log(arr);;
//            arr.unshift('e');
//            console.log(arr);

</script>
</body>
</html>
