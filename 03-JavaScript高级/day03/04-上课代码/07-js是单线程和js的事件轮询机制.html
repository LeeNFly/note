<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>
  //js是一门单线程的语言
//  js在工作的时候,一次只能做一件事,做完一件事,才能去做下一件事件
//  单线程 特点: 一次只能做一件事,做完一件才能做下一件,  ★ js代码是一行一行从上往下执行的, 并且执行完上一行, 才能执行下一行 (同步执行)
//  为什么js要设计成单线程?
//      js诞生为了做表单验证,势必操作dom,假如js是多线程,一个线程要删除元素,另一个要给元素添加样式.这样的话,js就不知道要做什么了,为了避免这个问题,js从一开始就设计成了单线程
//  V8引擎
//  栈: 用于存储基本数据类型, 存储变量, 所有的代码都会进入到栈里面执行.引用数据类型的地址是16进制的数字,所以也存储在栈中  栈是有大小限制的
//  栈存储数据是有大小限制的 而基本数据类型也是有大小限制的 所以存在栈里
//  堆: 用于存储引用数据类型 堆存储数据没用大小限制 而引用数据类型也不知道最大是多少 所以存在堆里
//  JS声明的变量和函数等数据, 以及后续对变量等数据进行赋值或其他操作, 数据会一直存储在浏览器内存中, 存储在栈或者堆中 保持数据 出栈后也会存储在内存中, 保持数据 只有在每次刷新页面, 或重新请求该页面, 内存重新加载时, 数据才会丢失, js重新执行, 才会重新加载 也就是重置变量, 重置数据
//  ★★★ 每次请求一个页面, 或页面跳转, 地址栏跳转等, 内存都会清空, 都会加载/重新加载请求的这个页面, 即重新解析渲染这个页面的html, css, 以及重新执行这个页面的js代码

//

// js中, 只要没有说是异步的, 则都是同步执行的


  // 浏览器工作原理说明:
  // 浏览器会对html, css 代码进行解析和渲染, 对js代码进行解析和执行
  // 浏览器对页面的解析和执行的顺序是从上往下解析和执行的, 包括html, css, js等其他.
  // 1. dom树,规则树,以及渲染树,都是加载存储在内存中的
  // 2. js对dom树, css规则树以及渲染树的操作,比如改变dom树htm结构,或者改变dom树上dom元素(标签节点)的样式或html结构等所其他操作都会同步保存在内存中, 除非页面重新加载(刷新页面或跳转页面)
  // 3. js中声明的变量，函数,以及其他所有数据,都是一直存储在内存中的，对数据的操作,比如赋值等所有其他操作，都会一直保存在内存中,除页面重新加载(刷新页面或跳转页面)
  // 4、js中所有声明的数据(变量, 5基本, 3复杂等所有数据), 都是一次声明, 多次使用的
  // 5、js中,所有访问/使用/操作/获取性等所有操作,获取的都是访问/使用/操作/获取当前执行获取性操作这段代码时，内存中此刻保存的对应的要获取的那个数据的值, 并且要等到获取到值之后, 才继续执行后面的操作, 代码..
  // 6、js中,所有的代码执行都是 立即 同步 生效的, 会先立刻把代码执行的影响立刻 同步 保存在内存里且生效, 之后再往下执行下一行代码 ... , 后面执行的代码都是基于之前执行的代码
//      比如执行赋值操作的代码, 会先将赋值同步更新到内存中, 然后再往下执行之后的代码; 比如dom操作, 会先将操作的影响、数据等同步更新到dom树内存中, 并渲染更新完页面后, 然后再往下执行之后的代码; dom中的获取性操作, 会先将值获取到, 然后再往下执行之后的代码 ... 等其他
//   7. js中, 只要没有说是异步的, 则都是 ★ 同步执行的, 即要等到上面的代码执行完毕后且★代码执行的影响保存更新到内存, 若涉及到页面渲染的(重绘或回流), 还要等页面重新渲染后, 才会继续执行后面的代码

  // js中，改改在dom树上的标签节点，即改变在dom树上dom元素的样式渲染模式,及html结构或其他所有等,只要影响页面的布局排列渲染或元素(标签)的渲染，都会触发对应的回流和重绘
  // 对于隐藏的元素display: none,不会被渲染到页面上,所以修改隐藏的元素,不会触发重绘和回流，除非隐藏的元素显示了,就会触发重绘和回流

</script>
</body>
</html>
