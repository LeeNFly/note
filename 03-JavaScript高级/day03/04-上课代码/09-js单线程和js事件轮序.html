<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>


  //js中,所有代码执行的时候,都会加载到栈中执行, (页面在解析的时候, 会先把所有的js代码都加载到栈中去执行) (执行完一个然后弹栈,执行下一个。JS是单线程的),(函数的调用,会先将函数中的数据加载到栈中,然后执行函数体,执行结束后出栈, 然后才会执行函数调用处之后的代码),
  //        函数只有在调用的时候才会进栈 然后执行函数体中的代码

  // ★★★ 每次调用函数, 都会在栈内开辟这次调用函数的空间, 将函数中数据加载到栈中执行, 如果连续多次调用同一个函数, 则这个函数会被多次加载到栈中执行, 且各个函数有自己的空间, 自己的变量, 互不干扰.

  //如果有定时器/事件处理函数(/ajax),不会立刻执行,定时器/事件注册在栈中执行后出栈(不会阻塞栈),然后他们会先在浏览器里暂时管理一下,并且栈继续往下执行下面的代码。当时间到了/事件被触发了.浏览器会把 回调函数 / 事件处理函数 ,放到任务对列中排队等待被调用执行.当栈里面的代码执行完毕了(栈空时),事件轮询就会把任务队列中的第一个拿到栈中执行(调用),执行完毕之后, 查看是否栈空, 若栈空, 事件轮询还会去任务队列中拿下一个,再放到栈里面执行
  // 事件轮询 做2件事情  一直在观察栈和任务队列,如果栈空了,就会去任务队列中拿第一个出来,然后放到栈里面执行。否则一直等待栈空
  // 事件轮询从任务队列中拿取任务放到栈中执行, 因为js是单线程的, 所以是一个一个拿的, 并且要等到上一个任务放到栈中执行完毕后, 若栈空, 再继续从任务队列中拿下一个任务放到栈中执行... (单线程)
  // ★★★ 所有异步操作的回调函数, 都是暂时由浏览器管理, 触发调用回调函数时都是先放到任务队列中去排队, 通过事件轮询机制, 等待被放到栈中去调用执行

  // js中, 只要没有说是异步的, 则都是同步执行的

  // v8引擎：  用来执行每一行js代码
  // webapi：  提供了很多方法,比如说定时器. 帮助我们计时..
  // 事件轮询： 一直观察栈和任务队列: 如果栈中的代码执行完毕了(栈空了),就去任务队列中拿第一个任务放到栈中执行. 会一直不停的重复执行刚才的动作
  // 任务队列： 定时器的回调函数/事件处理函数,触发时,不会立刻加载到栈中执行,会先存储到任务队列中排队,如果栈里面的执行完了(栈空时),才会拿任务队列中的当前排位第一个执行


  // 栈的大小是有限制的

//  function one(){
//    throw new Error('我自己写的错误');
//  }
//
//  function two(){
//    one();
//  }
//  two();

  console.log(1);
  setTimeout(function(){
    console.log(2);
  },1000);
  console.log(3);
  for(var i = 0; i <10000; i++) {
    console.log('hah');
  }

  // 打印顺序  1, 3, hah(10000), 2
  // 队列中的函数要等到栈空了才会拿到栈中去执行


</script>
</body>
</html>
