<!--
 * @Author: Ling Hui Shi
 * @Date: 2020-02-16 19:54:47
 * @LastEditors: Ling Hui Shi
 * @LastEditTime: 2020-04-20 22:12:37
 * @Description: 
 -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>


  //js中,所有代码执行的时候,都会加载到栈中执行, (页面在解析的时候, 会先把所有的js代码都加载到栈中去执行) (执行完一个然后弹栈,执行下一个。JS是单线程的),(函数的调用,会先将函数中的数据加载到栈中,然后执行函数体,执行结束后出栈, 然后才会执行函数调用处之后的代码),
  //        函数只有在调用的时候才会进栈 然后执行函数体中的代码

  // ★★★ 每次调用函数, 都会在栈内开辟这次调用函数的空间, 将函数中数据加载到栈中执行, 如果连续多次调用同一个函数, 则这个函数会被多次加载到栈中执行, 且各个函数有自己的空间, 自己的变量, 互不干扰.

  //如果有定时器/事件处理函数(/ajax),不会立刻执行,定时器/事件注册(ajax)都是异步的, 在栈中执行后立刻出栈(不会阻塞栈),然后他们会先在浏览器里暂时管理一下,并且栈继续往下执行下面的代码。当时间到了/事件被触发了.浏览器会把 回调函数 / 事件处理函数 ,放到任务对列中排队等待被调用执行.当栈里面的代码执行完毕了(栈空时),事件轮询就会把任务队列中的第一个拿到栈中执行(调用),执行完毕之后, 查看是否栈空, 若栈空, 事件轮询还会去任务队列中拿下一个,再放到栈里面执行
  // 定时器就是先短暂阻塞栈, 等到定时器注册上之后 (不会等定时器触发), 就不再阻塞栈, 栈就继续往下执行js代码了, 定时器的回调函数是异步的, 不会阻塞栈
  // 事件注册是先短暂阻塞栈, 等到事件注册上之后 (不会等事件触发), 就不再阻塞栈, 栈就继续往下执行js代码了, 事件的处理函数是异步的, 不会阻塞栈
  // ajax, 就是先短暂阻塞栈, 等到请求发送之后 (不会等请求响应), 就不再阻塞栈, 栈就继续往下执行js代码了, 成功 或 回调的处理函数是异步的, 不会阻塞栈
  // 事件轮询 做2件事情  一直在观察栈和任务队列,如果栈空了,就会去任务队列中拿第一个出来,然后放到栈里面执行。否则一直等待栈空
  // ★★★ 事件轮询从任务队列中按顺序拿取一个任务放到栈中执行, 因为js是单线程的, 所以是 ★★★ 一个一个拿的, 并且要等到上一个任务放到栈中全部执行完毕后, 若栈空, 再继续从任务队列中拿下一个任务放到栈中执行... (js是单线程)
  // ★★★ 任务队列中的任务, 是同步执行的, 即要等到上一个任务放到栈中全部执行完毕后, 下一个任务才有可能被执行(等到栈空时被放到栈中去执行)
  // ★★★ 所有异步操作的回调函数 或 异步执行的函数, 都不会阻塞栈, 都是暂时由浏览器管理, 触发调用回调函数时都是先放到任务队列中去排队, 通过事件轮询机制, 等待被放到栈中去调用执行
  // ★★★ 异步操作 实际上操作是同步且生效的 回调函数是异步的 回调函数由浏览器暂时管理 等到触发对应条件时 会被放到任务队列排队 等待栈空时被放到栈中执行 即调用函数 执行函数体 函数体中变量的访问规则根据词法作用域和当前执行代码时此刻内存中的数据为准
  // js中, 只要没有说是异步的, 则都是同步执行的

  // v8引擎：  用来执行每一行js代码
  // webapi：  提供了很多方法,比如说定时器. 帮助我们计时..
  // 事件轮询： 一直观察栈和任务队列: 如果栈中的代码执行完毕了(栈空了),就去任务队列中拿第一个任务放到栈中执行. 会一直不停的重复执行刚才的动作
  // 任务队列： 定时器的回调函数/事件处理函数,触发时,不会立刻加载到栈中执行,会先存储到任务队列中排队,如果栈里面的执行完了(栈空时),才会拿任务队列中的当前排位第一个执行

  // ★★★ js中, 所有异步操作, 都不会阻塞栈, 并且异步操作的回调函数是由浏览器暂时保管, 满足回调函数触发条件时, 会将回到函数放在任务队列中排队, 等待被调用, 被浏览器轮询机制管理
  //       当栈空时, 事件轮询会从队列中按顺序拿一个任务到栈中执行, 且当执行完毕后, 再次判断栈是否为空, 为栈空, 继续从任务队列按顺序拿一个任务到栈中执行 ....   每次只拿一个, 并且要等到上一个执行完毕后, 才继续判断栈空, 然后拿下一个任务放到栈中执行...  因为js是单线程的
  // 任务队列中的任务, 是同步执行的, 即要等到上一个任务放到栈中执行完毕后, 下一个任务才有可能被执行(等到栈空时被放到栈中去执行)


  // 栈的大小是有限制的

//  function one(){
//    throw new Error('我自己写的错误');
//  }
//
//  function two(){
//    one();
//  }
//  two();

  console.log(1);
  setTimeout(function(){
    console.log(2);
  },1000);
  console.log(3);
  for(var i = 0; i <10000; i++) {
    console.log('hah');
  }

  // 打印顺序  1, 3, hah(10000), 2
  // 队列中的函数要等到栈空了才会拿到栈中去执行


</script>
</body>
</html>
