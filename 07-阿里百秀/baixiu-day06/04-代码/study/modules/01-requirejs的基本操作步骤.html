<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <!--
      传统的js引入方式的缺点:
       1. 引入js是同步的, 可能会阻塞页面的渲染
       2. 多个文件之间, 可能会存在依赖关系, 维护起来不方便

      使用requirejs可以解决以上问题, requirejs最大的特点是异步加载, 来解决之前存在的引入js的问题
      明确: requirejs, 也是js
  -->

  <!-- 使用 requirejs 第一步, 引包 -->
  <script src="./require.js"></script>
  <script>
    
    /**
     * 1. 定义模块
     *    (1) 每个模块都一般是一个单独的js文件, 明确: 也是js
     *    (2) 每个模块都有自己独立的作用域, 因为在函数内, 不会被污染
     *    语法: define( '模块名', ['依赖项1', '依赖项2', ...], function() {
     *            // 加载依赖项 是异步的, 即同时执行所有依赖项的js文件, 不会阻塞代码, 他们之间的执行先后是不确定的
     *            //  ps: 依赖项可以是已定义的模块, 即 define( '模块名', ['依赖项1', '依赖项2', ...], function() { .. }
     *            //      如果依赖项是定义的模块, 则加载依赖项时 1> 先异步加载模块中的依赖项 2> 待所有依赖项加载完毕后, 调用模块的主体函数
     *            // 模块的主体函数, 在函数中写js代码, 该函数会在加载完所有依赖项后, 才调用, 确保调用时, 所有的依赖项都已经加载完毕
     *          })
     *    模块名可以省略不写, define(['依赖项1', '依赖项2', ...], function() {...}, 就是匿名模块
     *    可以没有依赖项, define([], function() {...}
     *    导出项: 定义在模块主体中的方法或者对象, 希望从模块中导出, 给其他模块使用
     * 
     *    ps: ★★★★★ 定义模块是不会自己加载依赖项和调用模块主体函数的, 需要加载模块(引入模块), 才会加载模块的依赖项, 并且执行模块的主体函数
     */

    /**
     * 2. 加载模块, 引入模块
     *    require( ['模块1的路径', '模块2的路径', ...], function() {
     *      // 每个模块加载都做了什么?  1> 加载模块中的依赖项, 2> 待依赖项全部加载完毕后, 调用模块的主体函数
     *      // 1) 先加载所有模块, 加载模块是异步的方式进行加载的, 所以模块是同时进行加载, 不会阻塞代码
     *      // 2) 等到所有模块都加载完毕后, 才调用fn, 在fn中写js代码, 调用时确保引入的模块全部加载完毕
     * 
     *    })
     * 
     * ★★★ 注意: 加载模块, 引入的模块 ( require( ['模块1的路径', '模块2的路径', ...], function() { ... }) 
     *       实际上就是在当前页面加载模块, 及模块的依赖项的, 是在当前页面发起请求去请求相关的js文件的
     *       所以, 引入的所有模块中的代码作用的是引入模块处的页面, 即和模块的引入处共同作用于相同的页面(标签和元素)
     */

    //  注意点: 模块路径后缀名 .js 可以省略, 一般推荐省略
    // require( ['./js/a'], function() {
    //   // 加载完 a 模块, 会调用回调函数
    //   console.log( "加载完 a 模块了")
    // })



    /**
     * 3. 定义(define)的模块中有导出项的情况
     *    (1) 在定义模块时, 在模块的主体函数中, 将需要导出的对象或者函数或数据通过, 通过return导出, 如果没有导出项, 则默认return undefined, 即导出项为undefined
     *    (2) 在加载该模块的主体函数中, 通过主体函数的形参接收导出项
     *    ps: 加载该模块有2种情况, 
     *          1. 一种是在定义模块A时候, 即 define( '模块名', ['依赖项1', '依赖项2', ...], function() { ... }, 
     *             通过依赖项加载模块B, 若模块B有导出项, 则在定义模块A的模块的主体函数中, 可以通过主体函数的形参来获取模块B的导出项
     *          2. 另一种是在引入模块, 即加载模块, require( ['模块1的路径', '模块2的路径', ...], function() { ... }
     *             通过fn的形参, 可以获取模块中的导出项
     */
    // require( ['./js/b'], function( obj ) {
    //   console.log( obj.add(1,2) );
    //   console.log( "b模块被加载了" );
    // });


    /**
     * 4. 有多个导出项, 引入多个模块的注意点
     *    引入 a, b, c 三个模块
     *    引入的模块路径顺序 和 导出项参数是 ★★★ 一一对应的, 如果该模块没有导出项, 默认 return undefined;
     *    由于是一一对应的, 所以就算不想接收没有导出项的模块, 也需要使用占位符.
     *    小技巧: 将没有导出项的模块, 放在最后面, 并且可以不用形参进行接收, 因为也不用
     */
    //  require( [ './js/b', './js/c', './js/a' ], function( mb, mc ) {
       
    //    console.log( mb );
    //    console.log( mc );

    //    console.log("回调函数被调用了")
    //  })


    /**
     * 5. 有依赖项的情况, need.js 依赖于 a, b, c 三个模块
     *    在定义模块时, 就会将依赖项定义好, 使用时直接引入即可 (会自动加载依赖项)
     */
    require( ['./js/need'], function() {
      console.log("need模块加载完成")
    })
  </script>

  
</body>
</html>