<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <style>
    /*
      弹性布局
      伸缩布局
      flex布局
    */


    * {
      margin: 0;
      padding: 0;
      list-style: none;
    }
    ul {
      width: 600px;
      height: 400px;
      border: 1px solid #000;
      margin: 100px auto;
      /* 只要给盒子指定 display: flex; 这个盒子就成为了伸缩盒子
         就拥有了主轴和侧轴的概念,
         默认主轴水平往右, 侧轴垂直往下, 内部的子盒子默认在主轴上从轴心开始, 往主轴方向排布

         注意:  一旦给盒子设置了display: flex, 盒子变成伸缩盒子, 则内部所有子盒子的显示模式发生改变, 没有什么块级 行内 行内块之分了
               相当于内部的所有盒子, 都变成一种相同的全新的显示模式, 类似于行内块, 都可以设置宽高, 由伸缩布局flex来管理和控制排布方式
               伸缩盒子内部的子盒子, 都可以设置宽高, 默认宽度为内容大小, 默认高度为当前行的高度, 如果不换行, 当前行的高度就是父盒子的高度
               宽高可以设置百分比, 参考父盒子大小

               默认主轴水平往右, 侧轴垂直往下, 内部的子盒子默认在主轴上从轴心开始, 往主轴方向排布, 且不会超出外部盒子的内容区域(content)范围

                给盒子设置display: flex, 内部所有盒子由flex来进行管理和排布, 但是外部盒子虽然显示模式是display:flex,
                但是没有脱标, 还在标准流内, 显示模式可以看作是和原来标签名的显示模式一致

                ★★★ 给盒子设置display:flex, 可以给内部盒子设置排布方式, 但无论如何排布, 始终都不会超出外部盒子内容区域content的范围

         1. flex-direction: 控制主轴方向, 设置给父盒子
            控制主轴的水平方向, 同时也会改变侧轴的方向和轴心的位置
            侧轴始终与主轴垂直, 且正方向指向盒子内部
            无论是主轴还是侧轴, 都是开始于轴心, 在超出盒子的内容区域content时结束

            ★★★ flex布局, 内部盒子的排布方向始终是沿着主轴线进行排布( 排列顺序由后面子元素的order决定, 默认的排列顺序是按照html结构的顺序进行排列 ) 即主轴方向决定了盒子的排布方向
                   侧轴不决定盒子的排布方向, 但是可以改变盒子在侧轴方向上的对齐方式
            row 主轴水平往右  默认值    ->  主轴水平往右, 侧轴垂直往下, 轴心在左上角,
            column 主轴垂直往下         ->  主轴垂直往下, 侧轴垂直往右, 轴心为左上角
            row-reverse (了解) 主轴水平往左    ->  主轴水平往左, 侧轴垂直往下, 轴心为右上角
            column-reverse (了解) 主轴垂直往上 ->  主轴垂直往上, 侧轴水平往右, 轴心为左下角

         2. justify-content: 设置给父元素, 控制内部所有子盒子在主轴方向对齐方式, ( 该属性可以设置单行或多行子盒子在主轴方向的对齐方式 )
              注意, justify-content 只是设置子盒子在主轴方向的对齐方式, 并不能改变盒子的排布方向,
                   如设置了flex-start 和 flex-end, 盒子的排布方向都是一致的, 都是沿主轴方向排列, 只是对齐方式不同而已.
                   例如给盒子排序 123, 则 flex-start 和 flex-end 得到的盒子序号沿主轴方向都是123, 只是对齐方向不一致

                   justify-content, 在盒子对齐之前, 已经先沿着主轴指向的方向排列好盒子了, 然后才开始对齐, 即在对齐之前, 已经先排列好盒子了, 然后才对齐

              flex-start: 让子盒子往主轴的开始位置对齐, 并且每个盒子间不留缝隙    默认值
              flex-end: 让子盒子往主轴结束位置对齐, 并且每个盒子间不留缝隙
              center: 让子盒子在主轴方向上居中对齐, 并且盒子与盒子间不留缝隙
              space-around: 让子盒子在主轴方向上平均排列, 将主轴方向多余的空间平均分配给每个盒子的两侧, (中间盒子间的间距是占2份, 主轴方向两端有空隙)
              space-between: 让子盒子在主轴方向上平均排列, 主轴方向两端没有空隙, 将主轴方向剩余的空间在盒子与盒子间平均分配

         3. align-items: 设置给父盒子, 控制内部所有子盒子在侧轴方向盒子对齐方式, ( 该属性只能设置 ★ 单行 的子盒子在侧轴方向对齐方式 )
              注意: align-items 只是设置子盒子在侧轴方向的对齐方式, 并不能改变盒子的排布方向
                   align-items, 在盒子对齐之前, 已经先沿着主轴指向的方向排列好盒子了, 然后才开始对齐, 即在对齐之前, 已经先排列好盒子了, 然后才对齐

              flex-start: 往侧轴开始位置对齐
              flex-end: 往侧轴结束位置对齐
              center: 在侧轴方向, 居中对齐,
              stretch: 在侧轴方向上拉伸, 盒子不能设高
      */
      display: flex;
      /* 主轴方向对齐方式 */
      justify-content: flex-end;
      /* 侧轴方向对齐方式 */
      align-items: center;
    }
    li {
      width: 100px;
      height: 100px;
      background-color: red;
      border: 1px solid #000;
      box-sizing: border-box;
    }
  </style>
</head>
<body>

<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>


</body>
</html>