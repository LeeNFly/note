
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>

</head>
<body>
    <script>

      // 变量 (重要)

      // 变量 : 可以变化的量
      // 作用 : 存储数据
      // 声明 : var 来声明 (★★★ 在js ES5中, 声明变量统一都使用var) (声明变量就是创建变量)
      // 变量一般要先声明, 然后才可以使用 (访问, 获取, 操作, 赋值等其他)
      // 以下规则都是var声明的变量有的
      // 声明变量, 变量名任意, 只要符合变量名命名规范即可
      // 如何来使用变量 :
      //1. 只声明
      // 结构 : var + 变量名   (变量名不能是字符串)  在ES5中 声明变量的方式只有var
      // (记忆) 只声明,,没有赋值的变量 => 变量的值都是 undefined  只声明是符合语法规范的,说明还没有进行完,后续会赋值的。
      // 赋值, 赋予变量值, 变量中存储的值就为赋的值, 改变变量中存储的值
      // ★★★ 若后续在相同作用域内(在相同作用域内,若是函数作用域,则是每个函数开辟的单独内存空间内(包含嵌套函数关系),即每个函数的作用域互不干扰,相互独立,不会冲突)声明相同变量名的变量，则相同作用域内后声明的变量会覆盖相同作用域中之前声明的同名变量 (在相同作用域内, 只要声明的变量名相同, 后面声明的变量就会覆盖前面的) , 不会报错
      //        即var声明的变量可以被var声明多次, 在相同作用域下, 后声明的变量会覆盖相同作用域中之前声明的同名变量 (前提后声明的变量要赋值, 否则不会覆盖, 值还是之前的), 不同作用域的变量互不影响和干扰.
      // 注意: ★ 使用/访问变量,使用/访问的都是变量的值(变量中存储的值)
      // ps: 操作, 访问, 获取, 输出 和使用变量, 都是操作, 访问和获取, 输出和使用变量的值, 即变量中存储的值; 我们可以通过操作变量来操作变量的值
      // ps: ★★★ js中所有的使用变量的地方, 都是使用变量的值, 即变量中存储的值, 而不是使用变量本身, ★★★
      //     如 var a = 1; var b = 2; var c = 3; var arr = [a, b]  => [1, 2]; arr.push(c); arr 为★★★ [1, 2, 3], 而不是[a, b, c], 因为使用变量是使用变量的值, 而不是变量本身
      //        a = { name: 'zs', age: 18 }; b = 6; c = 100 则arr还是[1, 2, 3], 因为是使用变量的值, 而非变量本身
      //     注意, 引用类型的数据, 值是引用地址
      // ★ 变量一次声明, 可以多次使用/操作/访问/获取/赋值 等.
      // ★ js中, 所有用到变量的地方, 用的都是变量的值, 变量只是存储数据的载体, 真正使用变量时, 还是使用其存储的值, 也就是变量的值

      // ★★★ 只有通过赋值运算符, 才会改变变量的值, 获取变量和使用变量, 不会改变变量的值
      // ★★★ 注意: 赋值赋的是值而非变量, 如果是基本数据类型, 则赋值前后互不影响, 如果是引用数据类型, 则赋值后, 指向同一个引用地址

      // 变量一般先声明, 然后再使用
       var p;
       console.log(p); //undefined

      //2. 先声明,再赋值
      // = : 赋值 (给等号左边的变量赋值) => 将等号右边的值(结果)赋值给等号左边(★★★一个变量只能存储一个值, 可以存储所有类型的数据, 可以多次赋值，后面的赋值会覆盖前面存储的值, 即后面的赋值会覆盖变量之前存储的值)
      // 变量中存储的值是可以改变的, 给变量赋值会改变变量中存储的值, 变量可以被多次赋值 (接受任意类型赋值) , 后面的赋值会覆盖前面存储的值, 即后面的赋值会覆盖变量之前存储的值 (每个变量只能存储一个值)
      // 变量可以存储任意类型的值, 即变量可以接收任意类型数据的赋值, 变量的数据类型以当前变量中存储的值的数据类型为准
      // 不同变量之间的值可以一样, 也可以不一样
      // ★ 变量赋值顺序, ★ 一定是 (无论如何) 都是从右往左, 先执行等号右边, 将右边的具体结果值算出来后, 再将右边的值赋值给等号左边 var p = 1;   p = p + 1 => 先执行右边的p + 1, 然后把结果赋值给左边的p => 执行结果, p 的值为 2
      // 赋值时 等号右边可以是变量 把变量存储的值赋予左边 ; 可以是具体的值 字面量 引用地址等其他
      // ★ 注意,赋值时,先执行等号右边,右边可以是复杂的表达式、函数的调用以及任何获取性操作, dom获取性操作等等, 一定是等到等号右边算出来具体值之后,再将等号右边的具体的值赋给等号左边
      // ★ 注意, 赋值时, 先执行等号右边, 等号右边的数据以此刻执行等号右边时内存中存储的数据为准.  var p = 1;   p = p + 1 => 先执行右边的p + 1, 此刻内存中p为1, 所以p + 1的值为2, 然后把结果赋值给左边的p => 执行结果, p 的值为 2
      // 可以将任意类型(五简单，3复杂)的变量/值/数据 赋值给var声明的变量 , var声明的变量,不管之前有没有赋值,都可以接收任意类型变量/值 的赋值 (5个简单类型,3个复杂类型),赋值后变量的数据类型也随之改变, 每个变量只能存储一个值, 后面的赋值会覆盖变量之前存储的值
      // var 声明的变量,可以接收任意数据类型(五简单，3复杂)的赋值(后面的赋值会覆盖前面的赋值). 可以存储任意数据类型的数据 赋值后变量的数据类型也随之改变, 每个变量只能存储一个值, 后面的赋值会覆盖变量之前存储的值
      // js中, 只要是变量：1.就只能存储一个值, 2.可以存储所有类型的数据, 3. 可以多次赋值, 可以接受所有类型的数据赋值, 后面的赋值会覆盖变量之前的值
      // 变量的值可以是任意类型的, 5简单, 3复杂
      // 变量都可以赋值

      // ★ 若赋值右侧是变量, 赋值是给左侧变量赋值, 是改变左侧变量的值, 不会改变右边变量的值, 
      // ★ 赋值表达式是给左侧赋值, 改变的是左侧的值, 并不会改变右侧的值.


      // ★★★ 只有通过赋值运算符, 才会改变变量(存储)的值, 获取变量和使用变量, 不会改变变量的值, 给变量赋值是一定会改变变量的值的
      var p ;
      p = 10;
      console.log(p);  // cconsole.log() 打印

      //3. 声明 + 赋值
      var p = 40;
      console.log(p);

      //4. 声明多个变量并赋值
      var a,b;  // 声明两个变量 : a 和 b
      // =>  var a;
      // =>  var b ;   => 分号  代表这一句结束
      // console.log(a);
      // console.log(b);

      var c = 10,d = 20; //=> var c = 10;var d = 20;
      console.log(c);
      console.log(d);

      // 连着打印
      console.log(c,d);

      //5. 不声明,只赋值 (隐式全局变量, 浏览器会自动在全局帮我们声明这个变量并赋值 不要这么使用 ES6完全放弃了 )
      e = 40;
      console.log(e);

      // 思考 :
      var c = 10 ,  d = 20,e = 1;
      var c = 10 ;
          d = 20;

      // 第一句 : 只有一个; 所以 var 不仅声明了c 还声明d ,最后看到; 结束
      // 第二句 :  遇到分号就结束

      //6. ★★★ 不声明,,不赋值 ,直接使用 . 会被当做是一个变量,然后又找不到 (变量未声明),所以报错 ps: 前端的报错信息也是打印在console控制台中
      // var num
      // num = 30;
      console.log(num);  // 报错 报错之后,代码不再继续往下执行




      var a = 10;
      var b = 20;

      console.log(a); //10 => 20
      console.log(b); //20 => 10

      // ==>




















    </script>
</body>
</html>
