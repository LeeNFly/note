<!--
 * @Author: Ling Hui Shi
 * @Date: 2020-02-16 19:54:46
 * @LastEditors: Ling Hui Shi
 * @LastEditTime: 2020-04-20 06:23:54
 * @Description: 
 -->
JavaScript, 简称js
1. 为什么要学习js ?
js : 表单验证
后来 : 无所不能

2. js
是一种运行在 客户端的 脚本语言
脚本语言 : 非编译语言, 脚本语言是 执行一行 解析一行 php/python : 由于是非编译语言,就算代码写错了,由于是执行一行,解析一行,(且是同步执行, 要等到上面一行代码执行完毕后, 才执行下面一行的代码) 就算代码写错了,只要写错的代码不被执行到,也是不会报错的;
// js是脚本语言, 非编译语言, 执行一行, 解析一行, 代码执行报错了, 程序停止运行, 报错之后的代码不再执行了, 但报错之前的代码还是会被执行的. 报错之前的代码已经执行完毕了 (解析一行, 执行一行)
★★★ js中, 后面只要没有说是异步的, 则全部都是 ★ 同步执行的, 
★★★ 同步执行: 即会阻塞栈中代码执行, 即要等到上面的代码执行完毕后且★代码执行的影响保存更新到数据库后, 才会继续执行下面的代码
3. js的组成
- ECMAScript :`标准` 规范、规定了js应该使用的 语法和数据类型 , 在浏览器中能够被识别和解析 (我们JS基础学习的是ECMAScript,并且是ES5 很重要)
- Dom : document object model 有一套`操作网页元素`的api (方法 接口) (在WebAPIs编程中学习)
- Bom : broswer object model  有一套`操作浏览器功能`的api  (在WebAPIs编程中学习)

ECMAScript中所有的操作都是同步的

★★★ 浏览器可以识别html, css 和js代码, 可以直接解析和执行html, css, 以及js代码, 会自动解析html, css, js代码, 然后自动将解析后结果渲染执行到页面上
★★★ 浏览器解析页面的顺序是从上往下同步解析、渲染和执行的, 包括html, css, js等. 都是同步解析、渲染和执行的

浏览器会对html, css 代码进行解析和渲染, 对js代码进行解析和执行
浏览器可以解析, 执行和渲染html、css、和js代码
浏览器解析页面的顺序是从上往下解析和执行的, 且要等到将上一行执行的影响更新保存同步到内存中生效之后, 才会继续往下执行下一行代码 (即是同步执行) 且都是同步解析和执行的 包括html, css, js等. 执行代码都是根据当前执行这行代码时内存中存储的数据为准

js的执行顺序是从上到下一行一行执行的. ★ 直到执行到最后一条js语句, 才会结束; 若遇到报错, 则报错之后的代码不再执行
js执行后, 所有的数据和操作还是会保留在浏览器内存里的, 持续作用于页面

js中碰到复杂表达式的 (复杂表达式也是表达式), 多个.操作的, 执行顺序 ★一般 是从左往右执行, 右边的操作是基于左边的操作的结果 进行操作的, 比如a.b.c.d, 从左往右依次执行, a().b().c().d(), 从左往右依次执行, 右边基于左边
即要先等到左侧的.操作完毕后, 拿到左侧.操作返回的值后, 才进行右侧的.操作, 类似于同步执行,要等到左侧.操作拿到具体值后, 然后再基于左侧的值, 进行右侧.操作.

浏览器工作原理说明:
    浏览器会对html, css 代码进行解析和渲染, 对js代码进行解析和执行
    浏览器对页面的解析和执行的顺序是从上往下一行一行解析和执行的, 且要等到将上一行执行的影响更新保存同步到内存中生效之后, 才会继续往下执行下一行代码 (即是同步执行) 且都是同步解析和执行的, 包括html, css, js等其他. 执行代码都是根据当前执行这行代码时内存中存储的数据为准
1. dom树,规则树,以及渲染树,都是加载存储在内存中的
2. js对dom树, css规则树以及渲染树的操作,比如改变dom树htm结构,或者改变dom树上dom元素(标签节点)的样式或html结构等所其他操作都会同步保存在内存中, 除非页面重新加载(刷新页面或跳转页面)
3. js中声明的变量，函数,以及其他所有数据,都是一直存储在内存中的， 持续作用于页面, 对数据的操作,比如赋值等所有其他操作，都会一直保存在内存中, 持续作用于页面, 除页面重新加载(刷新页面或跳转页面)
4、js中所有声明的数据(变量, 5基本, 3复杂等所有数据), 都是一次声明, 多次使用的, 可以被多次使用/操作/访问/获取/赋值等..
★★★ js中, 不管是在全局或者函数体中或者其他任意js运行环境中,  所有js代码都是一行一行从上往下 ★ 同步解析执行的, 
★★★ 同步解析执行: 即会阻塞栈中代码执行, 要等到执行完上一行js代码之后, 且要等到将上一行执行的影响更新保存同步到内存中生效之后, 才会继续往下执行下一行js代码 (即是同步执行)
★★★★★js是单线程语言, 不管是在全局或者函数体中或者其他任意js运行环境中, 所有js代码都是一行一行从上往下★同步★执行的, 即要等到执行完上一行js代码之后, 且要等到将上一行执行的影响更新保存同步到内存中生效之后, 才会继续往下执行下一行js代码 (即是同步执行)
★★★ js中, 只要执行js代码, 不管是在全局或者函数体中或者其他任意js运行环境中执行js代码, 当前执行的js代码用到的数据都是以此刻执行这段代码时, 内存中存储的数据为准, 当前的代码是在之前执行过的代码基础上(操作, 影响, 数据更新保存在内存后) 执行的.
5、js中, ★ 执行代码都是单线程的, 不管是在全局或者函数体中或者其他任意js运行环境中, js代码中, 所有的访问/使用/操作/ ★ 获取性等所有操作,获取的都是访问/使用/操作/获取当前执行获取性操作这段代码这一时刻，内存中此刻保存的对应的要获取的那个数据的值, ★ 并且要等到获取到值之后 / 操作和使用, 且影响保存更新到内存中之后, 才能继续执行后面的操作(比如赋值或其他所有操作), 代码..
6、js中, ★ 执行代码都是单线程的, 不管是在全局或者函数体中或者其他任意js运行环境中, 所有的js代码的执行都是 立即 同步 生效的, 会先立刻把代码执行的影响立刻 同步 更新 保存在内存里且生效后, 才会继续再往下执行下一行代码 ... , 后面执行的代码及其用到的数据, 都是基于之前执行的代码(操作, 数据及影响更新保存到内存后)上执行的
   比如执行赋值操作的代码, 会先将赋值同步更新到内存中, 然后再往下执行之后的代码, 比如dom操作, 会先将操作的影响、数据等同步更新到dom树内存中, 并渲染更新完页面后, 然后再往下执行之后的代码; dom中的获取性操作, 会先将值获取到 (获取此刻内存中dom树上对应的数据的值), 然后再往下执行之后的操作(比如赋值操作)、代码; 比如获取性操作, 要先等到值获取到之后, 才继续往下执行之后的代码 ... 等其他
   ★ 比如js中所有数据的创建, 都是同步执行的, 会先将创建的数据创建完毕并且保存到内存中生效之后, 才会继续往下执行之后的代码.

   ★★★ js中, 可以在js环境的任意地方, 不管是在全局或者函数体中或者其他任意js运行环境中执行js代码, 执行js中的操作, 包括赋值, 获取, 操作, DOM, BOM等 所有js中的所有语法和代码,
   
7. js中, 只要没有说是异步的, 则都是 ★ 同步执行的, 即会阻塞栈, 即要等到上面的代码执行完毕后且★代码执行的影响保存更新到内存后, 若涉及到页面渲染的(重绘或回流), 还要等页面重新渲染后, 才会继续执行后面的代码
8. js中, 变量数据在经过操作后(比如循环, 获取等其他所有操作), 数据还是会保留在内存里, JS对于使用到的数据, 都不会去删除的.
9. 变量的值会一直保存在内存里. 只有赋值操作会改变变量的值 (在内存中存储的值)

js中，改改在dom树上的标签节点，即改变在dom树上dom元素的样式渲染模式,及html结构或其他所有等,只要影响页面的布局排列渲染或元素(标签)的渲染，都会触发对应的回流和重绘
对于隐藏的元素display: none,不会被渲染到页面上,所以修改隐藏的元素,不会触发重绘和回流，除非隐藏的元素显示了,就会触发重绘和回流
