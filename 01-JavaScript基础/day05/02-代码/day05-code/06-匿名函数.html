
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>

</head>
<body>
    <script>

      //函数的声明方式3：匿名函数
      //1. 声明(创建函数) : function (参数1,参数2....) { 函数体 } 声明(创建)函数并返回函数的引用地址  (参数可有可无,与函数的区别就是没有函数名)
      //   调用匿名函数时也可以进行传参, 参数会被形参按照顺序一一对应接收
      //   同样,声明不会执行函数体,只要被调用的时候才会执行函数体
      //2. 自调用执行  结构 : ( 匿名函数 ) ()
      //3. 场景 :
      // 函数的声明  => fn
      function fn() {
        console.log('111');
      }

      fn();

      // 匿名函数  没有函数名的函数
      // 自执行/自调用(1次)
      // 结构 : ( 匿名函数 ) ()
      // 第一个括号 : 匿名函数保护起来
      // 第二个小括号 : 调用
      (function () {
        console.log('222');

      })();

      //3. 场景 :  以下就算给函数名 function name () {...} ,函数名也不起作用,所以直接给匿名函数
           // 以下匿名函数均可以带参数

      //3.1 方式2 声明函数
      var fn = function () {
        console.log('f');
      }
      fn();

      //3.2 函数作为参数
      //函数名可以看作参数名
      function test(num) {

        // var num = function () {
      // }
        console.log(num);
      }
      test(function () {

      })

      //3.3 函数作为返回值
      //函数名可以看作接收返回值的变量名
      function test1() {

        return function () {

        }
      }
     var res =  test1();

     //3.4 除了这个声明函数的方式, 其他地方使用到的函数, 基本上都是匿名函数
     function test() {

     }

     //3.5 对象中的函数属性值 => 属性名可以看作是函数名


    //  ★★★ 函数注意总结：
    //    1. 除了函数的声明方式1以外, function 函数名(参数..) {}, 其他所有用到函数的地方, 都使用匿名函数
    //    2. 所有函数, ★ 只要是函数 (不管函数在哪里声明的), 参数都是可有可无的, 且调用函数的时候都可以传参, 也可以不传参, 若传参, 参数都会被形参按照顺序一一对应接收
    // ★★★ 调用函数的时候, 先将实参的值赋值给形参, 然后才开始执行函数体. 即先确认每个形参的值之后, 才开始执行函数体中的代码
    //    3. 函数的声明, 也叫做创建函数, 可以通过以下三种方式创建函数: 1. function 函数名(参数..) { 函数体 }, 2. var 变量名 = function(参数..) { 函数体 }, 3.使用匿名函数创建函数 function(参数..) { 函数体 }
    //       以上三种方式都是函数的声明, 都是创建函数, 返回函数的引用地址, 且都可以被调用
    //       以上三种方式都是函数的声明, 不会执行函数体, 需要调用, 才会执行函数体中的代码
    //       函数体中可以写任意的js代码, 会在调用的函数的时候执行函数体中的代码, ★ 执行顺序也是从上往下同步执行的
    //       ★ ps: 后续所说的函数, 都是指函数的声明(创建), 即函数的引用地址, 
    //       ★ ps: 后续所使用到函数的API, 都是指函数的声明(创建), 即函数的引用地址, 我们只需要在使用处声明(创建)函数即可, 创建(声明)函数返回的是函数的引用地址(创建函数得到的结果为函数的引用地址)
    //       1) 创建函数(创建函数也叫声明函数, 声明函数也叫创建函数, 一个意思), 都会开辟一块新的空间存储, 都是返回函数的引用地址. 即声明(创建)函数得到的结果是函数的引用地址, 且声明(创建)的函数都可以被调用 2) 只要是创建函数(声明函数), 都不会执行函数体, 需要调用函数, 才会执行函数体中的代码. 每次调用, 执行一次函数体 3) 只要是函数, 不管在哪, 都不会自己执行函数体, 都需要调用函数, 才会执行函数体
    //       4) ★★★ 只要是创建函数(声明函数), 浏览器都不会去解析和执行函数体中的代码, 而是直接跳过, 等到调用函数的时候, 才会去解析和执行函数体中的代码, 函数体中变量具体的值, 以调用执行函数体的时候对应代码执行的时刻内存中存储的变量的值为准.
    //          ★★★ 由以上,可以知道, 同一个函数, 多次调用, 函数体的代码执行结果和函数最终的返回值有可能不同, 函数体中的数据是以本次调用函数执行函数体时此刻内存中存储的数据为准, 即每次调用函数, 函数体中变量的数据都有可能不一样
    //       5) 调用函数, 执行函数体, 函数体中访问/查找/使用/操作/赋值变量, 先在自身函数作用域内查找, 若找到就使用, 并停止查找, 若没找到, 则从函数的 ★★★声明所在处 开始, 沿着作用域链往上级链查找, 找到使用, 且停止查找, 后面同词法作用域2.3.4点！！
    //       6) ★ 调用函数, 执行函数体中代码, 函数体中代码执行顺序都是从上往下, 解析一行, 执行一行, ★同步★ 解析和执行的
    //       7)  调用函数, 都是 ★同步调用★的, 等到函数体中代码执行完毕后, 才会返回到函数调用处(并将函数返回值返回到函数调用处), 执行函数体之后的代码.
    
    //    4. 在JS任何地方 变量的值只要指向函数的(根据词法作用域查找规则), 或者说变量的值只要是函数的引用地址的, 就可以通过变量名() 调用对应的函数, 执行函数体 与函数在哪里声明的, 数据在哪里存储的无关, 与函数在哪个内存地址里存储无关.
    // ps: 调用函数, 不管函数在哪里声明, 不管函数在哪调用的, 函数调用结束后(执行完函数体后),  都会将return 后面的值, 即函数的返回值, 返回到函数的调用处, 返回什么值, 函数的调用处就拿到什么值

    //    5. 在JS任何地方, 只要是函数, 或函数的引用地址的, 都可以加()调用对应地址里的函数, 执行其函数体中的代码 与函数在哪里声明的, 数据在哪里存储的无关, 与函数在哪个内存地址里存储无关.
    //    函数的调用过程
    //       ★★★ 在JS任何地方 只要是函数的引用地址, 都可以加()调用对应的函数, ★ 与函数在哪里声明的, 数据在哪里存储的无关, 与函数在哪个内存地址里存储无关.
    //       ★★★ 调用函数, (不管函数在引入的哪个文件中, 哪个模块中, 哪个内存中声明的) 都会先回到函数声明所在处  执行函数体中的代码, 函数体中变量查找顺序也是从函数声明处函数体中开始, 根据词法作用域链规则依次往上查找.
    //       ★★★ 调用函数, 要等到执行函数体代码结束后, 才会重新回到函数的调用处, 并且将函数返回值返回到函数调用处, 继续往下执行函数调用处之后的js代码 (同步调用)
    // ps: 调用函数, 不管函数在哪里声明, 不管函数在哪调用的, 函数调用结束后(执行函数体代码遇到return, 即终止函数体代码执行, 跳出函数, 结束函数调用, 即函数调用结束), 都会将函数体中return 后面的值, 即函数的返回值, 返回到函数的调用处, 返回什么值, 函数的调用处就拿到什么值, 即调用函数最后得到的结果是函数的返回值
    
    //    6. 直接通过函数名()调用的, 会先在当前作用域查找函数, 若找到则直接调用, 停止查找, 否则会沿着作用域链往上级链找, 找到函数, 再调用, .. 后面同词法作用域2.3.4点！！
    //    7. 只要是匿名函数, 都支持外提, 外提后, 可以共用. 用方式1外提. 如function fn(参数..) {}, 可以使用fn 来代替原匿名函数. 因为fn的值一个函数的地址, 而原来的匿名函数也是返回一个函数的地址.
    //    8. 函数只需要一次声明, 就可以多次调用.  多次使用
    //    9. 不管是何处, 只要调用函数, 就会执行其函数体中的代码,
    //       函数体中查找/访问/使用/操作/赋值变量的规则: 先在函数体中查找, 若找到则直接使用, 并停止查找, 如果没有找到, 再从函数的 ★★★声明所在处, 沿着作用域链往上级链找, 找到就使用, 且停止查找, 后面同词法作用域2.3.4点
    //    9. 只有函数才可以 加 () 调用
    //    10. 调用函数都是同步执行的, 即同步调用, 即会阻塞栈, 要等到函数调用结束, 即函数体中代码执行完毕, 才会继续往下执行函数调用处之后的代码; 函数中可以调用其他函数, 也是是同步调用
    //    11. 函数调用结束后, 函数中声明的局部变量和函数等数据都会存储在函数的内存里, 保持数据, 不会消失
    //    12. 只要是函数, 不管在什么地方, 都是一次声明, 可以被多次调用
    //    13. 函数也可以看作是变量, 变量名为函数名, 变量值为函数的引用地址
    //    14. 函数调用,执行完函数体后,函数和函数中的变量不会消失,会继续存储在对应内存中, 多次调用函数, 每次调用函数, 在声明变量时, 对于相同作用域内声明同名的变量,后声明的变量会把之前相同作用域中声明同名的变量覆盖, 
    //        ★★★★★ 即多次调用函数, 每次调用同一个函数, 本次调用此函数执行函数体时, 函数体中声明的变量, 会覆盖之前调用此函数时函数体中声明的同名变量, 声明并拿到最新的值
    //    15. 后续有说到回调函数 就是函数, 只是换了称呼而已
    //    16. 调用函数, 执行函数体, 执行的是调用的函数的函数体, 即调用的函数的函数声明所在处的函数体中的代码
    //    17. ★ 虽然函数调用结束后会保留数据在函数中, 但多次调用函数, 每一次调用函数, 都会重新执行一次函数体, 函数体中声明的(局部)变量, 由于是同名变量, 由相同作用域内声明同名变量, 后声明的会覆盖之前相同作用域中声明的同名变量可知, 会覆盖之前函数调用保留的变量的数据.
    //        ★★★★★ 每个函数都有自己独立的作用域, 不同函数之间的作用域互相独立, 都是不同的作用域, 数据独立, 互不影响, 互不干扰, 数据不共享, 不能互相访问数据. 也不会互相覆盖数据
    //    18. 函数体中可以写任意的js代码 会在调用的函数的时候执行函数体中的代码, 函数体中代码的执行顺序也是从上往下依次 ★同步 执行, 函数体中代码执行完毕后, 会回到函数的调用处, 并且将函数返回值返回到函数调用处, 继续往下执行函数调用处之后的代码 (函数调用都是同步调用)


    //  ★★★ 关于自调用函数沙箱说明:
    //    1. 自调用函数 是 函数的 声明 + 调用一次 也称为沙箱 (function() {...})(); 会保持函数中的数据在函数中
    //       自调用函数若是匿名函数, 则只能被调用一次, 如果不是匿名函数, 则后续还可以被调用.
    //    2. 自调用函数调用后, 函数中声明的局部变量, 函数等数据都会继续存储在自调用函数的内存里,并且保持数据, 不会消失
    //    3. 自调用函数(沙箱)的作用, 在函数内部形成一个局部空间, 保护函数内部的局部变量, 函数, 数据不被全局和其他函数污染
    //        说明: 由作用域可以知道, 沙箱外是无法访问沙箱内的变量, 函数的, 所以沙箱外是无法对沙箱内的变量和函数进行篡改的
    //              除非沙箱自己把内部的变量, 和函数 暴露到全局(通过window. ), 这样全局就可以访问沙箱内暴露出去的数据了.
    //                根据值类型数据和引用类型数据可以知道,
    //                   1> 如果暴露出去的是值类型数据, 则外部无法通过暴露的变量直接修改
    //                   2> 如果暴露出去的是引用类型数据, 则外部可以通过暴露的变量直接修改, 因为暴露的是引用地址, 共同指向同一块内存地址里的数据, 则可以直接修改对应内存里的数据.
    //                      ps: 只要变量存储的是引用地址 就可以访问和使用地址里的数据 与地址里的数据在哪里存储 在哪个作用域存储 无关
    //              如果沙箱内暴露出去的函数的函数体中, 操作了沙箱内的数据, 则全局通过调用沙箱内暴露出去的函数, 也可以操作沙箱内未暴露出去的数据, 因为函数体执行的时候, 访问变量是从函数的声明位置开始往上级链找的, 而沙箱内的函数是在沙箱内声明的, 所以可以访问到沙箱内的任何数据.

    //    4. 沙箱可以看作是一块空间, 里面维护着沙箱里自己的变量, 函数, 和数据, 不受外部污染.
    //    5. 沙箱可以看作是局部的全局作用域, 沙箱中的数据会一直存储在沙箱里, 可以保持数据, 数据不会丢失和消失.
    //    6. 沙箱中的数据都是局部变量, 只能在沙箱中使用, 但是可以通过window. , 将沙箱里的数据暴露到全局, 供全局使用.


    // 形参实参补充说明:
  // 12. ★ 函数中的形参, 以具体调用函数时传递的实参值为准, 如果没有传实参, 则形参相当于只声明, 未赋值, 是undefined;
  //     ★★★  每次调用函数, ★★★ 都会重新声明所有形参, 所有形参的值会被重置为undefined, 然后将本次调用函数实参的一一对应值赋予形参, 对于没有传递实参的形参, 则对应的形参相当于只声明, 未赋值, undefined;
  //        function add (num) {
  //            console.log(num);
  //        }
  //        add(); // undefined
  //        add(3); // 3
  //        add(); // undefined

  // 13. ★ 函数中的形参, 在调用结束后, 也会保持数据, 但是下一次调用时候, 所有形参会重新进行声明, 所有形参会被重置为undefined, 然后将实参的值一一对应赋值给形参, 对于没有传递实参的形参, 对应的形参值为undefined
  //    function add (num) {
  //        console.log(num);
  //
  //        function con() {
  //            console.log(num);
  //        }
  //
  //        window.con = con;
  //    }
  //
  //    add(); // undefined
  //    con(); // undefined
  //
  //    add(3); // 3
  //    con(); // 3 保持了形参的数据
  //
  //    add(); // undefined -> 调用函数, 形参的值被重置为undefined, 因为没传实参, 则形参值undefined
  //    con(); // undefined 当前函数中的信产值为undefined







    </script>
</body>
</html>
