
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>

</head>
<body>
    <script>

      // 值类型和 引用类型
// 变量在赋值时 都会在内存中开辟一块空间 , 然后将所赋的值存储在这块空间里
// 只声明变量 不赋值的话, 是不会开辟空间的
// 若后续声明相同变量名的变量，则后声明的变量会覆盖之前声明的变量

// 简单数据类型(基本数据类型) (number,string,boolean,undefined,null) 因为变量存储的时候,存的是值本身 存储在 内存 中
//   =====>也叫值类型
// 值类型变量 对应的内存里,存的是值本身,不是地址。是把 字面值 存储到了自己的内存空间里, 不会受到其他空间中值的影响.  值类型数据 ★ 作为(函数的)参数传递时,传递的是字面值, 不是地址  ★ 传递后的值和传递前的值, 互不干扰, 互不影响 ; 值类型数据  作为赋值右侧时,赋的是值本身,不是地址  ★ 赋值前的值和赋值后的值 互不干扰, 互不影响; 在使用值类型数据时, 使用的是值本身, 使用前和使用后互不干扰
      // 只要是值类型数据, 则不管如何操作和使用, 操作使用前和操作使用后都是互不影响, 互不干扰的, 因为值类型存储的是值本身, 而不是引用地址

      // 比如 var obj = {name: 'zs', age: 14} , var name = obj.name (对象中的name是基本数据类型, 传递的是值类型数据, 互不干扰), obj.name = 'ls', 则
      // console.log(name, obj.name) => zs ls , 值类型数据赋值, 赋值前的值不会影响赋值后的值

      // 使用值类型数据, 使用前和使用后互不干扰
      // var age = 18;
      // obj = { name: 'zs', age: age}
      // age = 66
      // console.log(obj) // { name: 'zs', age: 18 }
      // 值类型, 使用前和使用后, 互不影响
// 值类型变量在创建时,会在内存中开辟一块空间,然后将值存在这个空间里,值类型变量存的就是值本身,即值类型变量的值就是值本身
// ★★★ 变量只能存储一个值,可以多次赋值,后面的赋值会覆盖变量之前的值

//======================

// 复杂数据类型 (函数,数组,对象),,因为变量存的时候,存的是引用地址
//  =====>也叫引用类型
// 所有复杂数据类型(函数,数组,对象)在创建时(构造函数创建或字面量创建或任何方式创建),都会在 内存 中开辟一块 ★新的 空间,将数据存储在这块空间里 (可以存储任意类型数据),然后 ★ 将该空间的引用地址,返回 (一般赋值给变量存储 或 直接使用) 。所以变量里存的是引用地址,指向地址对应的那块数据,存储复杂数据类型的变量也叫作引用变量,引用变量的值存的都是引用地址,引用变量的值,都是引用地址
// 存储复杂数据类型的变量, 存储的都是引用地址, 也称作引用变量, 就和普通变量一样, 只不过换个叫法而已, 也可以被赋值多次, 接受多种类型数据的赋值等, 其实就是普通变量, 和其他变量一样
// ★★★ 复杂数据类型的数据在创建时, 其引用地址就确定且固定了, 后续若使用/改变/获取 引用地址里的数据, 并不会改变其引用地址
// ★ 由以上可知, 如果变量 ★ 存储的是引用地址 ★ 的, 则变量对引用地址中的数据获取/操作/修改, 并不会改变变量存储的引用地址的值, 即不会改变变量的值, 除非给变量重新赋值, 变量的值才会改变
// 虽然引用数据类型,变量存的值是引用地址,但是可以 操作/改变/赋值/获取 到地址所指向内存里的数据.
// 引用数据类型变量 对应的内存里, 存的值是数据的引用地址. 即引用数据类型变量 (引用变量) 值是引用地址
// 引用数据类型数据都是存储在一块地址里,而复杂数据类型指向引用地址,修改添加获取赋值属性等操作都是操作指向的那个引用地址里的数据
// 引用变量存的是 (值是) 复杂数据类型的引用地址,可以操作获取修改赋值以及使用所指向内存里的那块地址里的数据, 所有的操作都是修改指向那块地址里的数据, 引用变量本身的值还是那块数据的引用地址
// 引用类型数据的变量,赋值时,赋的是引用地址,数据存储在引用地址里。该变量值是那个引用地址 (指向那个引用地址) 。变量存的值是数据的引用地址。
// 引用类型变量(存储复杂数据类型的变量)作为等号右侧 赋值给其他变量(左侧变量) 是把所指地址赋值给其他变量(左侧变量) 共同指向同一个地址 同一块内存 同一块数据, 同一个对象/数组/函数
// 引用变量操作数据(添加修改删除、排序等其他),操作/改变/获取/赋值 等 的都是所指向内存里的那个引用地址里的数据。
//  只要变量存储的是引用地址的, 即变量的值是引用地址的, 都可以获取/操作/设置/访问/使用/改变 引用地址里的数据.
// 一个引用地址, 可以被多个变量所指向, 即可以多个变量, 指向同一块引用地址
// ★ 若多个引用变量指向同一个引用地址,只要某一个引用变量对引用地址里的任意类型数据做出改变,因为指向的是同一个地址,同一份数据,则所有指向同一个地址的引用变量的属性也会发生改变 (再访问数据时对应的值也会发生改变,因为所指地址中的数据已经发生改变了).
// 函数等执行调用的时候再开辟一块内存空间,局部变量都存储在函数开辟的内存空间里;
// 引用变量(引用类型数据)作为(函数的)参数传递时,传递的是引用地址, 共同指向同一个对象 ;作为赋值右侧时,赋的是地址,共同指向同一个地址, 同一个对象/数组/函数
// 若多个引用变量指向同一个引用地址,只要某一个引用变量对引用地址里的任意类型数据做出改变,因为指向的是同一个地址,同一份数据,则(之前或之后)所有指向同一个地址的引用变量的对应属性也会发生改变 (访问数据对应的值也会发生改变,因为所指地址中的数据已经发生改变了).
// ★★★ 注意:
//           1. 变量对引用地址里的数据做出改变, 不会改变引用地址的值. 引用地址在复杂类型数据创建时就固定了, 不会改变.
//           2. 多个变量指向同一个引用地址, 一个变量对引用地址里的数据做出改变, 则其他变量再访问这块地址里的数据时, 数据也会发生改变, 因为是指向同一块地址. (变量访问引用地址里的数据会发生改变, 但变量本身存储的值没变, 和原来一样, 还是这块数据的引用地址)
//           3. 多个变量指向同一个引用地址, 若其中一个变量重新赋值, 赋值成其他的值了, 则该变量不再指向原来那块引用地址了, 与原来那块引用地址及其数据就没有任何关系了, 也不会影响和改变其他指向原来那块引用地址里的变量 (只有赋值才会改变变量的值) .  指向原来那块引用地址里的变量仍指向原来那块引用地址 (只有赋值才会改变变量的值)
// ★★★ 变量只能存储一个值,可以多次赋值,后面的赋值会覆盖变量之前的值

// 变量存储复杂数据类型虽然存储的是地址,但是通过console.log打印可以看到地址里具体存储的数据

// 注意： 引用类型数据创建了, 就会存在内存里 如果引用变量不指向引用数据了, 引用数据也不会消失, 还是会存在内存里 然后拥有一个自己的地址


//  ps: ★ 只要是指向引用地址的变量, 就可以操作, 获取和使用 访问 修改 引用地址里的数据; 与引用地址的数据在哪声明创建, 数据在哪里存储无关
//      ★ 只要是引用地址, 就可以操作, 获取和使用 访问 修改 引用地址里的数据, 与引用地址的数据在哪声明创建, 数据在哪里存储无关.
//      ★ 只要变量存储的是引用地址 就可以操作 访问和使用和修改和操作引用地址里的数据 与地址里的数据在哪里存储 在哪个作用域存储 无关

// 全局变量存储在script内,函数外的内存空间里，全局变量和局部变量可以同名,互不干扰
// ★★★ 变量只能存储一个值,可以多次赋值,后面的赋值会覆盖变量之前的值

// var num = 11;
// var num1 = num;
// num = 20;
// console.log(num);
// console.log(num1);

// var obj = {
//   name:"zs",
//   age:18
// }

// var obj1 = obj;
// obj1.name = "ls";
// console.log(obj.name);
// console.log(obj1.name);

// <!--
// 函数等执行调用的时候再开辟一块内存空间,局部变量都存储在函数开辟的内存空间里
// function fn(a, b) {
//   // 函数的参数 其实就是函数内部的局部变量
//   a = a + 1;
//   b = b + 1;
//   console.log(a);
//   console.log(b);
// }

// var x = 10;
// var y = 20;
// fn(x, y);
// console.log(x);
// console.log(y); -->


// function fn(x, y) {
//   // 函数的参数 其实就是函数内部的局部变量
//   x = x + 1;
//   y = y + 1;
//   console.log(x);
//   console.log(y);
// }

// var x = 10;
// var y = 20;
// fn(x, y);
// console.log(x);
// console.log(y);

// var p = {
//   name:"zs",
//   age:18
// }
// function fn(person) {
//   person.name = 'ls';
//   console.log(person.name);
// }
// fn(p);
// console.log(p.name);

function Person(name, age, salary) {
   this.name = name;
   this.age = age;
   this.salary = salary;
 }
 function f1(person) {
   person.name = "ls";
   console.log(person.name); //ls
 }
 var p = new Person("zs", 18, 1000);//创建一个新对象
 console.log(p.name);// zs
 f1(p);
 console.log(p.name);// ls



    </script>
</body>
</html>
