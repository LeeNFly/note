
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>

</head>
<body>
    <script>

//       > 作用域：变量起作用的区域

// **全局作用域** ：在script标签内或js文件内，**函数外**的区域就是全局作用域，在全局作用内声明的变量叫做**全局变量** 。全局变量可以在任意地方访问。

// **函数作用域** ：在  **函数内的区域**   叫做函数作用域，在函数作用域内声明的变量叫做**局部变量** ，局部变量只能在 当前 函数体内 及当前函数体内 嵌套的子孙函数内 才能访问到。在其他函数中都无法访问和使用。

// ★★★★★ 每个函数都有自己独立的函数作用域, 不同函数之间的作用域互相独立, 都是不同的作用域, 数据独立, 互不影响, 互不干扰, 数据不共享, 不能互相访问数据. 也不会互相覆盖数据
// ★ 不同作用域中, 变量可以同名, 存储在不同的内存里, 是2个东西, 互不影响, 互相独立, 不会覆盖, 互不干扰
// ★ 在相同作用域中, 声明同名变量, 后声明的同名变量会覆盖之前声明的同名变量

// 全局变量：在函数外，script标签内(全局作用域)声明的变量就是全局变量，全局变量在任何地方都能访问和使用。

// 局部变量：在函数中(函数作用域)声明的变量，就是局部变量，局部变量只能在 当前函数体内及当前函数嵌套的子孙函数能够访问和使用, 在其他函数中都无法访问和使用。

// 隐式全局变量：没有使用var定义的变量也是全局变量，叫做隐式全局变量。(不要使用)

// 全局变量存储在全局内存中, 局部变量存储在所在函数的内存中, 形参也是局部变量, 也存储在所在函数的内存中

// 外部作用域不能访问内部作用域中数据, 内部作用域可以访问外部作用域数据 (根据词法作用域)


// 总结:
// 全局作用域 : script标签内, 函数外
//            全局变量 => 任何地方都可以访问
// 函数作用域 : 函数内部
//             局部变量 => `当前函数`内部访问

// 除了两个常用的变量还有 隐式全局变量 : 任何地方都能访问(前提是已经好)   (避免使用)(先执行函数)
// ★ 函数 也是 变量,变量名为函数名 值为声明的函数的引用地址, 先要访问到函数名对应的函数, 才可以调用函数

      // 全局变量,在全局作用域内开辟一块内存空间,存储;局部变量,在局部作用域内开辟一块内存空间,存储;
      //1.  里面的能访问外面的, 外面的不能访问里面的  =>  里面:函数作用域 ; 外面: 全局作用域
      //★   全局变量在全局作用内开辟内存空间存储,局部变量在局部作用域内开辟内存空间存储 ; 全局变量和局部变量互相独立,互不干扰
      //2. 访问/使用/查找/操作/赋值变量的时候,先在自己的作用域中查找, 找到了直接使用(可以获取值, 也可以赋值),并停止查找 如果找不到就沿着作用域链往上级链找,找到了直接使用(可以获取值, 也可以赋值),停止查找,找不到继续往上找 (只能往上找,不能往下找),直到全局, 后面同词法作用域2.3.4点！！

      //    函数作用域 访问/操作/赋值 变量,先找当前函数作用域里的局部变量,若找到,直接操作(可以获取值, 也可以赋值),并停止查找;若找不到,再从 ★★★ 当前函数体出发,沿着作用域链一层一层往上级链找,找到了直接使用,停止查找,找不到继续往上级链找,直到全局作用域找全局变量,若还是没找到,没找到: 若是取值,则报错;若是赋值,则隐式全局 ;
      //    全局作用域 访问/操作/赋值 变量, 只能在全局作用域中找
      //2.  局部变量和全局变量名字可以相同, 是不同的东西,  存储在不同的内存里 各自独立, 不会冲突, 不会互相影响, 不会互相覆盖, 访问时根据词法作用域规则访问(全局变量在全局作用内开辟内存空间存储,局部变量在局部作用域内开辟内存空间存储,这2个虽然同名,但 存储位置不同 , 不会冲突且互不影响 , 是2个独立的变量 ,且 作用范围不同 ) ,函数作用域 访问/操作/赋值 变量,优先找函数作用域里的局部变量,若找到,则不去全局作用域找;若找不到,则沿着作用域链一层一层往上级链找直到全局作用域找全局变量, 后面同词法作用域2.3.4点！！ ; 全局作用域 访问/操作/赋值 变量, 只能在全局作用域中找
      //    ★ 形参相当于局部变量, 所以形参也可以和全局变量同名. 互相独立, 互不影响, 存储在不同的内存里, 是2个不同的东西
      //3.  JS中只有全局作用域和函数作用域.在函数作用域以外,script标签内定义的变量都是全局变量。
      //    形参也是局部变量,相当于在当前函数作用域内声明了一个局部变量,只能在 当前 函数作用域内使用,在局部作用域内,在局部作用域内开辟空间存储.

      // ★★★ js中任意地方, 不同变量中存储的值可以相同, 也可以不相同, 值都是存储在变量自身的内存空间里的, 互不干扰, 互不影响, 互相独立!!!
      // 不同变量: 变量名不同 或 变量存储的内存不同 都是js中的不同变量, 变量存储位置不同, 变量名相同, 也是不同的变量
      // ★   在js中, 不同变量, 存储的值可以相同, 也可以不同, 与变量是否同名无关, 同名的不同变量存储的值也可以相同, 也可以不同, 只要是在不同作用域中或不同作用域链中或不同函数中, 同名变量都是不同的变量, 同名的值可以相同, 也可以不相同
      // ★★★即, 在js中, 各个变量(存储)的值, 可以相同, 也可以不同!!!

      //★   不同函数之间的形参可以同名,因为是在各自的函数作用域开辟内存空间存储, 存储在不同的内存空间里, 是不同的东西, 各自独立, 不会冲突, 互不影响, 不会互相覆盖,  存储在各自的作用域内存中, 存储在不同的内存里 无法互相访问
      //★   不同函数之间的局部变量可以同名,因为是在各自的函数作用域开辟内存空间存储, 是不同的东西, 各自独立, 不会冲突, 互不影响, 不会互相覆盖, 存储在各自的作用域内存中, 是存储在不同的内存里 无法互相访问
      //★   不同函数之间的局部变量 是不同的东西, 存储在不同的内存中, 存储在各自的内存中, 各自独立 不会冲突, 互不影响, 不会互相覆盖, 存储在不同的内存里 访问时根据词法作用域规则访问
      //★   不同作用域中, 变量可以同名, 因为存储在不同的作用域内存里, 是2个东西, 互不影响, 互相独立, 不会覆盖, 互不干扰
      //★   在相同作用域中, 声明同名变量, 后声明的同名变量会覆盖之前声明的同名变量
      // 函数也是变量:
      //★   相同作用域内, 若声明的函数名相同(只要函数名相同), 根据预解析规则, 则后声明的同名函数会覆盖之前声明的函数
      //★   不同作用域中, 变量可以同名, 因为存储在各自的作用域内存中, 存储在不同的作用域内存里, 是2个东西, 互不影响, 互相独立, 不会覆盖, 互不干扰
      //★   不同作用域中, 不同函数中, 声明的函数名可以相同, 因为在不同作用域中, 不同函数中, 变量可以重名不冲突, 不会覆盖, 根据词法作用域规则进行访问
      //     1>只要是不同函数, 不管是同级的或者是其他函数或者是嵌套的函数(父函数和子孙函数), 形参名就可以相同, 因为是存储在不同的内存里, 是不同的东西, 不同函数之间的形参是独立的, 互不干扰, 互不影响 不会互相覆盖 存储在不同的内存里 访问和使用形参时根据词法作用域规则访问
      //     如arr.forEach(function(v, i) {
      //        arr1.forEach(function(v, i) {
      //            不同函数之间的形参名可以相同, 不同函数之间的形参是独立的, 存储在不同的内存里, 互不干扰
      //            访问时通过词法作用域链进行查找
      //            arr2.forEach(function(v,i) {

      //            })
      //        } )
      //   } )
      //    2>只要是不同函数, 包括嵌套函数 (子孙函数和父函数), 或其他同级函数或其他函数, 不同函数之间的函数作用域内的局部变量名可以相同, 因为是存储在不同的内存里的, 不同函数之间的局部变量是独立的, 互不干扰互不影响, 不会互相覆盖 访问和使用变量时根据词法作用域规则访问
      //     如arr.forEach(function(v, i) {
      //        var a = 1
      //        arr1.forEach(function(v, i) {
      //            不同函数之间的局部变量可以相同, 不同函数之间的局部变量是独立的, 存储在不同的内存里, 互不干扰
      //            访问时通过词法作用域链进行查找
      //            var a = 2
      //            arr2.forEach(function(v,i) {
      //                var a = 3
      //            })
      //        } )
      //   } )
      //  3> 只要是局部变量(包含形参), 变量名就可以和全部变量相同, 存储在不同的内存里, 不会冲突. 互不干扰 互不影响
      //4.  在全局作用域声明的函数,可以在任意位置使用;在函数内部声明的函数,只能在函数内部使用.
      // ★★★ 每个函数都是一块独立的空间(不管是相对于全局作用域还是其他函数(包括内部嵌套、同级函数)),函数与全局作用域,其他函数间互不干扰。函数中的变量、形参都是存储在自己这块独立的空间里的,与其他函数或全局作用域互不干扰,变量名、形参名可以与其他函数或全局作用域中的变量名相同。访问顺序:先访问自己的,再一层一层往外找 (自己内部=>外层函数?.. => 全局作用域)。访问规则,里面可以访问外面的,外面不能访问里面的

      //4.  函数内部也可以声明函数,不过函数内部声明的函数是局部的,只能在函数内部使用,函数外部无法使用。
      //5.  函数中可以嵌套函数,外层函数的局部变量可以在内层函数中使用,内层函数的局部变量不可以在外层函数中使用。即里面可以访问外面,外面不能访问里面。内外层函数中变量,形参也可以同名(在各自的函数作用域内存储,不会冲突),内层函数访问变量,先访问自己的,没有再一层层往外找 (自己内部=>外层函数?.. => 全局作用域)
      //6.  每个函数都是开辟自己的空间存储,与其他函数相互独立,不会冲突。函数中的变量,形参,只能在 当前 函数 及当前函数嵌套的子孙函数中使用,在 其他函数中无法访问和使用。
      //7.  函数内只能访问 ★ 自己函数内部 的局部变量 和 全局变量,无法访问其他 同级 函数中的变量。

            // ps: 不同的函数, 是不同的函数作用域, 互相独立,
      //8 if else ; switch ; while ; do..while; for 循环  如果在全局作用域,则他们中声明的变量就是全局变量;如果在函数作用域,则他们中声明的变量就是当前函数中中的局部变量, 他们的作用域是由外部if, for .. 所处的作用域决定的, 自身无法决定, 他们中访问变量也遵循作用域链原则

      //9 ★★★ 调用函数时候， 函数访问变量是从函数的声明 所在处 开始查找, 若找到则直接使用, 若找不到则沿着作用域链往上级链查找, 找到就使用, 停止查找。后面同词法作用域2.3.4点！！

      // 作为参数的函数 与 函数调用处 同级



// ★★★ 函数调用后不会消失 还会存在内存里 函数里声明的局部变量也不会消失 也会存在内存里 保持数据  一次声明 多次调用 但是每次调用函数体的代码都会执行一次

// ★★★★★ 每个函数都有自己独立的作用域, 不同函数之间的作用域互相独立, 都是不同的作用域, 数据独立, 互不影响, 互不干扰, 数据不共享, 不能互相访问数据. 也不会互相覆盖数据

      var num =  12;  // 全局作用域  全局变量

      function test() {

        var num = 30;

          // 函数作用域

          var num2 = 22; // 局部变量

          num3 = 10;// 像这种只赋值,没有声明的变量,,隐式全局变量

          console.log(num);
          console.log(num3);
          console.log(num4);


      }

      test();

      // console.log(num2);

      console.log(num3);

      if (true) {
        var num4 = 40; //全局变量
      }

      console.log(num4);


    </script>
</body>
</html>
