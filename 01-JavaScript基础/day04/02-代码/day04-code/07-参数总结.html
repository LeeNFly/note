
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>

</head>
<body>
    <script>

      //声明
      // num1 num2 : 形参
      // 1. 形参可有可无 , 也可以有多个,中间用逗号,隔开
      // 2. 形参的命名 : 形参的命名类似于变量名, 不能是字符串, 命名规范 => 参考变量名的命名规范
      // 3. ★ 它是没有值意义的,只是占个位置,值纯粹是靠调用函数时实参传过来的 ★ 形参名可以任意 
      //    ★ 形参的命名与实参没有任何关系, 形参命名可以任意, 只要符合变量的命名规范即可, 将来将实参的传递的值 ★ 按照顺序, 一一对应赋值给形参的, 与形参的命名以及实参的传递的值无关, 只是按照实参传递的顺序和形参的顺序一一对应赋值
      // 4. 形参 只能在当前函数体内部使用 , 可以在当前函数体内部任意地方使用 , 不能在函数外部使用 , 形参相当于在当前函数内声明了2个局部变量(参照的是上面的num1, num2), 但是未赋值(只声明未赋值), 要等到调用时实参传递的值会一一对应赋给形参
      // 5. 如何确定形参?, 把不确定的值,作为形参
      // 6. 形参可以设置多个
      // 7. 可以接收任意类型 (5基本3复杂) 实参传什么值过来, 形参就一一对应接收什么值
      // 8. 形参前面不要var声明,直接写形参名即可
      // 9. 不同函数之间的形参可以同名,因为是在各自的函数作用域开辟内存空间存储,不会冲突 不会互相影响, 不会互相覆盖, 存储在不同的空间里, 各自独立, 访问时根据词法作用域规则访问
      //     1.>  包括嵌套函数 (子孙函数和父函数), 或其他同级函数或其他函数, 只要是不同函数, 其形参名就可以相同, 不同函数之间的形参是独立的, 存储在不同的内存里, 互不干扰互不影响, 访问和使用形参时根据词法作用域
      //     如arr.forEach(function(v, i) {
      //        arr1.forEach(function(v, i) {
      //            不同函数之间的形参名可以相同, 不同函数之间的形参是独立的, 存储在不同的内存里, 各自独立, 互不干扰, 不会冲突, 不会互相影响, 不会互相覆盖, 访问时根据词法作用域规则访问
      //            访问时通过词法作用域链进行查找
      //            arr2.forEach(function(v,i) {

      //            })
      //        } )
      //   } )
      // 10. 形参相当于在当前函数作用域内声明了一个局部变量 只能在当前函数及当前函数嵌套的子孙函数中访问和使用, 在其他函数中无法访问和使用. 形参就是所在函数的函数体中的局部变量
      // 11. 对于实参传过来的值,形参一一对应接收,对于没有传过来的值,则形参为undefined,相当于只声明了形参,但未赋值 (不会报错)
      // ps: 实参的个数和形参的个数可以不一致, 不会报错 (可以更多也可以更少也可以一样), 但是函数调用时形参是按顺序一一对应接收实参传递过来的值的, 即实参是按顺序一一对应赋值给形参的. 对于没传递实参的形参, 则形参的值为undefined

      // 12. ★ 函数中的形参, 以具体调用函数时传递的实参值为准, 如果没有传实参, 则形参相当于只声明, 未赋值, 是undefined;
      //     ★★★  每次调用函数, ★★★ 都会重新声明所有形参, 所有形参的值会被重置为undefined, 然后将本次调用函数实参按顺序一一对应值赋予形参, 对于没有传递实参的形参, 则对应的形参相当于只声明, 未赋值, undefined;
      //        function add (num) {
      //            console.log(num);
      //        }
      //        add(); // undefined
      //        add(3); // 3
      //        add(); // undefined

      // 13. ★ 函数中的形参, 在调用结束后, 也会保持数据, 但是下一次调用时候, 所有形参会重新进行声明, 所有形参的值会被重置为undefined, 然后将实参的值一一对应赋值给形参, 对于没有传递实参的形参, 对应的形参值为undefined
      //    function add (num) {
      //        console.log(num);
      //
      //        function con() {
      //            console.log(num);
      //        }
      //
      //        window.con = con;
      //    }
      //
      //    add(); // undefined
      //    con(); // undefined
      //
      //    add(3); // 3
      //    con(); // 3 保持了形参的数据
      //
      //    add(); // undefined -> 调用函数, 形参的值被重置为undefined, 因为没传实参, 则形参值undefined
      //    con(); // undefined 当前函数中的信产值为undefined


      // ★★★ 调用函数的时候, ★ 先将实参的值赋值给形参后, 然后才开始执行函数体. 即先确认每个形参的值之后, 才开始执行函数体中的代码

      // 一个函数多次调用, 由以上知道, 每次调用会先重置形参为undefined, 然后以该次调用函数传递的实参为准, 按顺序一一赋值给形参.

      function sum (num1,num2) {
        // 形参相当于var num1,num2;
        // 实参传值给形参,相当于
        // var num1 = 10;

        console.log( num1 + num2);

      }

      // 调用
      // 10 20 实参
      //1. 实际参数, 调用函数的时候可以进行传参
      //2. 可以传任意类型 (5基本3复杂), 即实参可以是任意类型
      //3. 传过去的值,,形参按照顺序一一对应接收
      //4. 当调用函数的时候,实参的值会按照顺序一一对应传递(赋值)给形参 (实参只负责传值, 不关心形参名叫什么, 将来是按照顺序一一对应赋值的, 与形参名无关!!!)
      //5. 若调用函数的实参是一个函数的调用,则会等参数中函数调用结束后,将函数的返回值作为实参,再调用函数
      //6. 若调用函数的参数是一个表达式的,则会先计算出表达式的值,然后将表达式的值作为实参 再调用函数
      //7. 可以是字面量, 也可以是变量, 如果是变量, 传递的就是变量的值
      //   即函数的实参可以是表达式, 函数的调用等, 会等表达式算出具体的值, 或者取得函数调用的返回值后, 才调用函数, 即等实参的具体值确定后, 才调用函数, 传递实参的值
      //   调用函数时, 实参可有可无, 实参可以有多个, 多个实参之间用逗号,隔开, 将来实参的值按顺序一一对应传递(赋值)给调用函数的形参
      // 最好 :几个形参 对应几个实参
      // ★ 调用函数, 实参是赋值给形参的, 所以传递的是值, 而非变量!!!
      // ★★★ 调用函数的时候, 先将实参的值赋值给形参, 然后才开始执行函数体. 即先确认每个形参的值之后, 才开始执行函数体中的代码

      sum(10,20)
      // =>  sum()  调用
      // => (10,20)  传参

    </script>
</body>
</html>
