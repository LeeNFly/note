<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Document</title>

</head>

<body>
  <script>

    // js代码执行的真正过程
      // 1. 先进行预解析 (把声明提升)
      // 2. 然后再一行一行的代码执行

    // 预解析
    




    // 1.var 声明的变量,,,把声明提升到当前作用域的最前面,赋值不提升,保持原来的位置
    //--------------
    //console.log(num) //报错
    //--------------
    // console.log(num)  // undefined,不报错
    // var num = 10;
    //--------------
    // 预解析,把声明提前,赋值不提前,相当于以下
    // var num;
    // console.log(num);
    // num = 10;
    //--------------

    // 2.函数的*声明 整体提升到当前作用域的最前面,注意,函数的调用不会提升,保持在原来的位置
    // 2.1 声明方式1,整体提升
    // test(); // , 不报错, 正常执行函数体
    // function test() {
    //   var num1;
    //   console.log(num1);
    //    num1 = 20;

    // }

    // 相当于
    // function test() {
    //   var num1;
    //   console.log(num1);
    //    num1 = 20;

    // }
    // test(); //undefined , 不报错
    

    // 2.2 对于var 声明的函数 (方式2),只将声明提升到当前作用域最前面,赋值不提升
      // 函数的声明
   

    // fm(); //报错

    // var fm = function () {
    //   console.log('好久没有夸马哥帅了');
    
    // }

    // 相当于:

    // var fm;

    // fm(); //报错

    //  fm = function () {
    //   console.log('好久没有夸马哥帅了');
    
    // }


    //1. 整体提升
    // function test() {
    //   console.log('好久没有夸马哥帅了');
    
    // }

    //2. var 声明的函数
    // var fm; 提升,赋值不提升




    // 3.函数同名,,后者会覆盖前者
    // test(); //玮哥帅


    // function test() {
    //   console.log('马哥帅');
      
    // }
    // function test() {
    //     console.log('玮哥帅');
        
    // }

    // 相当于
    // function test() {
    //     console.log('玮哥帅');
        
    // }
    // test(); //玮哥帅


      // 4. 变量 和 函数 同名,,函数优先
      // console.log(test); //帅

      // var test = 12;


      // function test() {
      //   console.log('帅');
        
      // }

      // 相当于:
      // function test() {
      //   console.log('帅');
        
      // }
      // console.log(test); //帅

      // js代码执行的真正过程
      // 1. 先进行预解析 (把声明提升)
      // 2. 然后再一行一行的执行代码
        var a = 10;
        console.log(a);//10
        a = 20;
        console.log(a);//20
        a = function () {
          console.log('aa');
        };
        console.log(a);
        // ƒ () {
        //   console.log('aa');
        // }
        
      // 总结 : 
      // 预解析: (全局作用域和函数作用域都会预解析)
      //1. 用var 声明的变量或函数(方式2),,,把声明提升到*当前作用域  的最前面
      //  赋值不提升,保持原来的位置
      //2. 函数的 声明 (方式1) ★ 整体提升到 ★ *当前作用域 的最前面,注意,函数的调用不会提升,保持在原来的位置
      // 函数的声明方式1, 会将函数整体提升到最前面, 相当于函数的声明被提升了
      // 函数的声明方式2, 只会提升变量名, 不会提升后面的声明的函数, 所以提升的变量名相当于只声明, 未赋值
      //3. 相同作用域内 函数同名(包括方式1和方式2),,后者会覆盖前者 ( (function () {...})() 自执行的匿名函数除外,不会覆盖)
      //4. 相同作用域内 变量 和 函数 同名,,函数优先 (函数会覆盖变量)
      
      // 当前作用域 => 全局作用域 或 函数作用域  具体情况具体分析 
      
      // 注意：因为只是把声明提前了,赋值和函数的调用没有提前,所以不会影响代码一行一行执行的执行结果。
      

      




  </script>
</body>

</html>