<!--
 * @Author: Ling Hui Shi
 * @Date: 2020-02-16 19:54:47
 * @LastEditors: Ling Hui Shi
 * @LastEditTime: 2020-04-19 23:32:49
 * @Description: 
 -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Document</title>

</head>

<body>
  <script>


    // 函数的声明与调用
    // js中只有函数, 只不过又把函数也可以叫作方法  函数名 => 方法名
    // 函数的声明
    // ps: 后续所说的函数, 都是指函数的声明, 即函数的引用地址
    // ★ ps: 后续所说的函数, 都是指函数的声明(创建), 即函数的引用地址, 
    // ★ ps: 后续所使用到函数的API, 都是指函数的声明(创建), 即函数的引用地址, 我们只需要在使用处声明(创建)函数即可, 创建(声明)函数返回的是函数的引用地址(创建函数得到的结果为函数的引用地址)

    // 结构 :
    // 函数名类似于变量名 , 不能是字符串 函数名命名规则要符合变量名的命名规则
    // ★ 每个函数都是一个变量,变量名为函数名 值为声明的函数(的引用地址)
    // 方式1声明函数, 相当于在当前作用域创建了一个变量, 变量名为函数名, 变量的值为函数的引用地址
    // function 函数名() {
    //   // 函数体 (代码块)
    // }

    // 函数的声明 (创建)
    function sayHi() {
      console.log('萨瓦迪卡');
    }


    //打印函数名
    console.log(sayHi);
    // 打印结果如下: 函数名类似于变量. 存储的是函数的地址
    // ƒ sayHi() {
    //   console.log('萨瓦迪卡');
    // }

    // 直接声明的函数,,是不会自己执行的 (即声明函数,不会执行函数体中的代码)
    // ★★★ JS中, 只要遇到函数的声明,都不会去解析和执行函数体中的代码,而是声明(创建)后, 直接跳过, 等到真正调用函数的时候,才会去具体解析和执行函数体中的代码,函数体中使用的变量的值,以调用函数执行函数体的时候此刻内存中存储的值为准 (以调用执行函数体的时候对应代码执行的时刻内存中存储的变量的值为准.)
    // ★★★ 由以上,可以知道,函数声明的时候若函数体中的变量,数据等没有,没有关系,不会报错, 因为js遇到函数的声明不会去解析和执行函数体, 而是直接跳过的. 只要调用函数体执行的时候(调用函数),函数体中的变量等数据有,就符合要求, 程序正常运行, 不会报错.若调用函数执行函数体的时候变量等数据没有,则会报错。函数体中的数据一切都以调用函数,执行函数体的时候当前内存里的数据为准  (JS是非编译语言,执行一行,解析一行)
    // ★★★ 由以上,可以知道, 同一个函数, 多次调用, 函数体的代码执行结果和函数最终的返回值有可能不同, 函数体中的数据是以本次调用函数执行函数体时此刻内存中存储的数据为准, 即每次调用函数, 函数体中变量的数据都有可能不一样
    // ★★★ 调用函数执行函数体的时候, 函数体中访问/查找/使用/操作/赋值变量, 先在自身函数体作用域内查找, 若找到直接使用, 且停止查找, 若没找到, 则从函数的 ★★★声明所在处 开始, 沿着作用域链往上级链查找, 找到就使用, 且停止查找, 后面同词法作用域2.3.4点！！
    // 需要调用它 ( 直接加(), 即可调用函数, 执行函数体中代码 ),才能执行函数体中的代码 (即调用函数,才会执行函数体中的代码), 每次调用, 执行一次函数体, 且调用函数都是同步执行的, 即会阻塞栈, 要等到函数调用结束后, 才会回到函数调用处, 继续往下执行函数调用处之后的代码
    // 函数体中可以写任意的js代码(包括赋值代码, 获取代码, 操作, DOM, BOM 等所有js中的语法和代码!!!, 都会按照js执行规则进行解析执行的) 会在调用的函数的时候执行函数体中的代码, 函数体中代码的执行顺序也是从上往下依次 ★同步 执行, 等到函数体中代码执行完毕后(函数调用结束), 才会回到函数的调用处, 继续往下执行函数调用处之后的代码 (函数调用都是同步调用)
    // ★ 调用函数, 执行函数体中代码, 函数体中代码执行顺序也都是从上往下解析一行, 执行一行, 且都是★同步★ 解析和执行的, 执行代码都是根据当前执行这行代码时内存中存储的数据为准, 要等到上一行的代码执行结束并且将影响更新到内存中之后, 才会继续执行下一行代码
    // ★★★ 如何判断函数调用结束: 如果执行函数体过程中执行了return ... , 则终止函数体执行, 函数调用结束, 回到函数调用处继续执行函数调用处之后的代码, 若函数体中代码全部执行完毕还没有执行到return ... , 在浏览器默认帮我们在函数体的最后默认加上return undefined, 终止函数体执行, 结束函数调用, 回到函数调用处继续执行函数调用处之后的代码
    // 调用函数, 都是 ★同步调用★的, 等到函数体中代码执行完毕后(函数调用结束), 才会返回到函数调用处(并将函数返回值返回到函数调用处), 执行函数体之后的代码.
    // 函数可以多次调用 (一次声明,多次调用),每次调用都会执行函数体,拿到的数据都当前内存里的数据值, 是最新的
    // 函数一次声明, 可以多次使用
    // ★★★ 函数调用后不会消失 还会存在内存里 函数里声明的局部变量和函数等数据也不会消失 也会继续存在内存里 保持数据  一次声明 多次调用 但是每次调用函数体的代码都会执行一次
    // 函数如果不调用,,将毫无意义
    // 函数调用,执行完函数体后,函数和函数中的变量和数据不会消失,会继续存储在函数对应内存中, 多次调用函数, 对于相同作用域内声明同名的变量,后声明的变量会把之前此函数作用域中声明的变量覆盖
    // ★★★★★ 函数调用,执行完函数体后,函数和函数中的变量不会消失,会继续存储在对应内存中, 多次调用函数, 每次调用函数, 在声明变量时, 对于相同作用域内声明同名的变量,后声明的变量会把之前相同作用域中声明同名的变量覆盖, 
    // ★★★★★ 即多次调用函数, 每次调用同一个函数, 本次调用此函数执行函数体时, 函数体中声明的变量, 会覆盖之前调用此函数时函数体中声明的同名变量, 声明并拿到最新的值
    
    // 虽然函数调用结束后会保留数据在函数中, 但多次调用同一个函数, 每一次调用函数, 都会重新执行一次函数体, 函数体中声明的(局部)变量, 由于是同名变量, 由相同作用域内声明同名变量, 后声明的会覆盖相同作用域中之前声明的同名变量可知, 会覆盖之前函数调用保留的变量的数据.
    // ★★★★★ 每个函数都有自己独立的作用域, 不同函数之间的作用域互相独立, 都是不同的作用域, 数据独立, 互不影响, 互不干扰, 数据不共享, 不能互相访问数据. 也不会互相覆盖数据
    
    //       ★ ps: 后续所说的函数, 都是指函数的声明(创建), 即函数的引用地址
    
    // 函数的调用
    // 结构 :  函数名()  / 也可以说是 函数引用地址 ()   /   也可以说是  函数()
    // 函数体执行完毕后,退出函数返回到函数的调用处, 并且将函数返回值返回到函数调用处, 继续往下执行 函数调用处 之后的代码

    // ★★★ 每次调用函数, 都会在栈内开辟这次调用函数的空间, 将函数中数据加载到栈中执行, 如果连续多次调用同一个函数, 则这个函数会被多次加载到栈中执行, 且各个函数有自己的空间, 自己的变量, 互不干扰.

    // js中, 对于有用的函数, 会一致保留在内存里, js会自行判断该函数和内存中的其他变量数据 是否有关联, 有关联则会继续保留

    // 调用函数, 执行函数体, 执行的是调用的函数的函数体, 即调用的函数的函数声明所在处的函数体中的代码

    // 函数中可以声明变量, 函数中声明的变量为局部变量


    //    函数的调用过程
    //       ★★★ 只要是函数的引用地址, 都可以加()调用函数, 与函数在哪里声明的, 数据在哪里存储的无关, 与函数在哪个内存地址里存储无关.
    //       ★★★ 调用函数 (不管函数在引入的哪个文件中, 哪个模块中, 哪个内存中声明的) , 都会先回到函数声明所在处执行函数体中的代码, 函数体中变量查找顺序也是从函数声明处函数体中开始, 根据词法作用域链规则依次往上查找.
    //       ★★★ 调用函数, 要等到执行函数体代码结束后(函数调用结束), 才会重新回到函数的调用处, 并且将函数返回值返回到函数调用处, 继续往下执行函数调用处之后的js代码 (同步调用)
    // ps: 调用函数, 不管函数在哪里声明, 不管函数在哪调用的, 函数调用结束后(执行函数体代码遇到return, 即终止函数体代码执行, 跳出函数, 结束函数调用, 即函数调用结束), 最后都会将函数体中return 后面的值, 即函数的返回值, 返回到函数的调用处, 返回什么值, 函数的调用处就拿到什么值, 即调用函数最后得到的结果是函数的返回值

    // ★ 相同作用域内, 若声明的函数名相同(只要函数名相同), 根据预解析规则, 则后声明的同名函数会覆盖之前声明的函数
    // ★ 不同作用域中, 不同函数中, 声明的函数名可以相同, 因为在不同作用域中, 不同函数中, 变量可以重名不冲突, 不会覆盖, 根据词法作用域规则进行访问
    sayHi();
    sayHi();
    sayHi();









  </script>
</body>

</html>
