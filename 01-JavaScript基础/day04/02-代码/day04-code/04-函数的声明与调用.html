<!--
 * @Author: Ling Hui Shi
 * @Date: 2020-02-16 19:54:47
 * @LastEditors: Ling Hui Shi
 * @LastEditTime: 2020-04-10 20:05:14
 * @Description: 
 -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Document</title>

</head>

<body>
  <script>


    // 函数的声明与调用
    // js中只有函数, 只不过又把函数也可以叫作方法  函数名 => 方法名
    // 函数的声明
    // ps: 后续所说的函数, 都是指函数的声明, 即函数的引用地址
    // 结构 :
    // 函数名类似于变量名 , 不能是字符串 函数名命名规则要符合变量名的命名规则
    // 函数也是个变量,变量名为函数名 值为声明的函数(的引用地址)
    // 方式1声明函数, 相当于在当前作用域创建了一个变量, 变量名为函数名, 变量的值为函数的引用地址
    // function 函数名() {
    //   // 函数体 (代码块)
    // }

    // 函数的声明 (创建)
    function sayHi() {
      console.log('萨瓦迪卡');
    }


    //打印函数名
    console.log(sayHi);
    // 打印结果如下: 函数名类似于变量. 存储的是函数的地址
    // ƒ sayHi() {
    //   console.log('萨瓦迪卡');
    // }

    // 直接声明的函数,,是不会自己执行的 (即声明函数,不会执行函数体中的代码)
    // ★★★ JS中, 只要遇到函数的声明,都不会去解析和执行函数体中的代码,而是声明(创建)后, 直接跳过, 等到真正调用函数的时候,才会去具体解析和执行函数体中的代码,函数体中使用的变量的值,以调用函数执行函数体的时候此刻内存中存储的值为准 (以调用执行函数体的时候对应代码执行的时刻内存中存储的变量的值为准.)
    // ★★★ 由以上,可以知道,函数声明的时候若函数体中的变量,数据等没有,没有关系,不会报错, 因为js遇到函数的声明不会去解析和执行函数体, 而是直接跳过的. 只要调用函数体执行的时候(调用函数),函数体中的变量等数据有,就符合要求, 程序正常运行, 不会报错.若调用函数执行函数体的时候变量等数据没有,则会报错。函数体中的数据一切都以调用函数,执行函数体的时候当前内存里的数据为准  (JS是非编译语言,执行一行,解析一行)
    // ★★★ 调用函数执行函数体的时候, 函数体中访问/查找/使用/操作/赋值变量, 先在自身函数体作用域内查找, 若找到直接使用, 且停止查找, 若没找到, 则从函数的 ★★★声明所在处 开始, 沿着作用域链往上级链查找, 找到就使用, 且停止查找, 后面同词法作用域2.3.4点！！
    // 需要调用它,才能执行函数体中的代码 (即调用函数,才会执行函数体中的代码), 每次调用, 执行一次函数体, 且调用函数都是同步执行的, 即会阻塞栈, 要等到函数调用结束后, 才会回到函数调用处, 继续往下执行函数调用处之后的代码
    // 函数体中可以写任意的js代码 会在调用的函数的时候执行函数体中的代码, 函数体中代码的执行顺序也是从上往下依次 ★同步 执行, 函数体中代码执行完毕后, 会回到函数的调用处, 继续往下执行函数调用处之后的代码 (函数调用都是同步调用)
    // 函数可以多次调用 (一次声明,多次调用),每次调用都会执行函数体,拿到的数据都当前内存里的数据值, 是最新的
    // 函数一次声明, 可以多次使用
    // ★★★ 函数调用后不会消失 还会存在内存里 函数里声明的局部变量也不会消失 也会继续存在内存里 保持数据  一次声明 多次调用 但是每次调用函数体的代码都会执行一次
    // 函数如果不调用,,将毫无意义
    // 函数调用,执行完函数体后,函数和函数中的变量和数据不会消失,会继续存储在函数对应内存中, 多次调用函数, 对于相同作用域内声明同名的变量,后声明的变量会把之前此函数作用域中声明的变量覆盖
    // ★★★★★ 函数调用,执行完函数体后,函数和函数中的变量不会消失,会继续存储在对应内存中, 多次调用函数, 每次调用函数, 在声明变量时, 对于相同作用域内声明同名的变量,后声明的变量会把之前相同作用域中声明同名的变量覆盖, 
    // ★★★★★ 即多次调用函数, 每次调用同一个函数, 本次调用此函数执行函数体时, 函数体中声明的变量, 会覆盖之前调用此函数时函数体中声明的同名变量, 声明并拿到最新的值
    
    // 虽然函数调用结束后会保留数据在函数中, 但多次调用同一个函数, 每一次调用函数, 都会重新执行一次函数体, 函数体中声明的(局部)变量, 由于是同名变量, 由相同作用域内声明同名变量, 后声明的会覆盖相同作用域中之前声明的同名变量可知, 会覆盖之前函数调用保留的变量的数据.
    // ★★★★★ 每个函数都有自己独立的作用域, 不同函数之间的作用域互相独立, 都是不同的作用域, 数据独立, 互不影响, 互不干扰, 数据不共享, 不能互相访问数据. 也不会互相覆盖数据
    
    // 函数的调用
    // 结构 :  函数名()  / 也可以说是 函数引用地址 ()   /   也可以说是  函数()
    // 函数体执行完毕后,退出函数返回到函数的调用处,继续往下执行 函数调用处 之后的代码

    // ★★★ 每次调用函数, 都会在栈内开辟这次调用函数的空间, 将函数中数据加载到栈中执行, 如果连续多次调用同一个函数, 则这个函数会被多次加载到栈中执行, 且各个函数有自己的空间, 自己的变量, 互不干扰.

    // js中, 对于有用的函数, 会一致保留在内存里, js会自行判断该函数和内存中的其他变量数据 是否有关联, 有关联则会继续保留

    // 调用函数, 执行函数体, 执行的是调用的函数的函数体, 即调用的函数的函数声明所在处的函数体中的代码

    // 函数中可以声明变量, 函数中声明的变量为局部变量


    //    函数的调用过程
    //       ★★★ 只要是函数的引用地址, 都可以加()调用函数, 与函数在哪里声明的, 数据在哪里存储的无关
    //       ★★★ 调用函数, 会先回到函数声明所在处执行函数体中的代码, 函数体中变量查找顺序也是从函数声明处函数体中开始, 根据词法作用域链规则依次往上查找.
    //       ★★★ 调用函数, 要等到执行函数体代码结束后, 才会重新回到函数的调用处, 继续往下执行函数调用处之后的js代码
    sayHi();
    sayHi();
    sayHi();









  </script>
</body>

</html>
