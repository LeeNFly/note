<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    // async 和 await ：异步编程的终极解决方案
    // 说明：这种用法是基于 Promise 的！！！

    function fn() {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve('666 888')
        }, 2000)
      })
    }

    // async 用来修饰一个函数
    // async 在 function 关键字之前 
    // 只要是函数, 前面都可以加async修是 (箭头函数, 你们函数, ES6对象函数简写形式等)
    async function foo() {
      // await 关键字只能用在 async 修饰的函数中！！！
      // await 关键字后面跟一个 Promise 对象 (await用在Promise对象之前, 用来修饰Promise对象的)
      // await 会等待该Promise封装的异步操作执行完毕后，才会执行后面的代码 
      // await实际上是先阻塞栈中代码执行, 等Promise对象调用resolve后, 才会继续执行await 之后的代码
      // res 就是 Promise 中调用 resolve 函数时传递的参数 (必须要配合await res才是resolve传递的参数数据)
      const res = await fn()
      console.log('await 后的结果为：', res)
    }
    // 由之前, vue中调用函数是同步调用的, 
    // 加了async但是内部没有使用await的函数, 调用此函数还是同步调用的
    // 加了async但是内部使用了await的函数, 调用此函数就变成异步调用了, 不会阻塞栈, 会在浏览器任务队列中排队, 等待栈空时被调用执行

    // 所有支持Promise的API, 其内部都封装好了, 会在内部封装的异步操作的回调函数中 resolve(返回的数据), 所以await会一直阻塞栈中代码的执行, 直到Promise内部异步操作的回调函数被执行调用, 才会调用resolve(返回的数据) 返回数据到await处, 然后才会继续执行await之后的代码. 

    foo()
  </script>
</body>

</html>