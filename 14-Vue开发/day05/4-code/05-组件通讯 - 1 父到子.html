<!--
 * @Author: Ling Hui Shi
 * @Date: 2020-03-21 13:54:45
 * @LastEditors: Ling Hui Shi
 * @LastEditTime: 2020-04-13 22:12:22
 * @Description: 
 -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <!-- 父组件的模板 -->
  <div id="app">
    <!-- 子组件的模板 -->
    <hello ppp="18" gender="male" :parentmsg="msg"></hello>
  </div>

  <script src="./vue.js"></script>
  <script>
    // 1 父到子
    // 父组件：vm实例
    // 子组件：hello组件

    // 1 在使用位置的子组件标签上添加一个标签属性（ppp）, 属性名任意, (标签属性的属性值双引号不能丢) 后续接收时要根据属性名一一对应接收, 标签属性的属性值就是将来要传递给子组件的数据, 可以传递任意类型数据
    //   ps: 父组件可以向子组件传递多个数据, 在使用子组件的标签上添加多个标签属性即可. 
    // 2 在components中的对应子组件中对象中添加props属性, 通过 props 属性，来接受这个数据,
    //    props是一个数组, 数组中每个元素是一个字符串, 根据字段名一一对应接收1. 中子组件标签上同名的标签属性对应的标签属性值, 可以接收任意类型的父组件传递给子组件的值
    //    props数组中, 每个元素虽然是字符串, 但是要与1. 中定义的标签属性名一一对应, 这样才能一一对应接收传递过来的标签属性值.
    //    这样, 在子组件中就接收到了父组件中传递的数据了, 就可以在子组件中使用父组件传递过来的数据了
    // 3 在子组件的模板视图template中就可以使用接受到的 ppp 数据了, 使用方式与data相同
    //    使用方式: 在子组件中, 会自动把父组件传递过来的数据拷贝一份放到子组件的vue实例中, 属性名为props中对应字段名(非字符串), 属性值为对应传递过来的值,
    //    通过vue实例.属性名 就能直接访问到 对应传递过来的数据了, 在this指向vue实例的函数中, 可以直接通过this.属性名来访问获得和使用父组件传递过来的数据了
    //    在组件视图模板template中, 在插值表达式, 或指令中, 可以直接通过props中对应的字段名(非字符串), 就可以访问获取和使用对应的父组件中传递过来的数据
    //    注意: 1. 父组件传递数据给子组件, 实际上是通过赋值传递, 传递的是值本身, 而不是将变量传递, 传递前后没有影响(引用地址除外)
    //          2. 在子组件中是不能修改(不能赋值)父组件中传递过来的数据的, 即是只读的, 只能获取和使用
    //              特殊: 若父组件传递给自组件的是一个引用地址(比如对象), 则在子组件中可以改变引用地址里的数据, 并且由于是同一个引用地址, 父组件中的对应引用地址里的数据也会发生改变(即使引用地址没有发生改变), 也会重新渲染页面并将改变后的数据自动传递给子组件, 会触发父子组件的页面视图重新渲染
    //                    因为传递的是引用地址, 而改变引用地址里的数据并不会改变引用地址本身, 所以也就没有改变父组件中传递过来的引用地址, 所以这样操作是被vue中所允许的
    //          3. 可以在使用子组件处的标签上可以将标签属性转化成指令(通过v-bind), 这样及可以使用vue指令特性了(标签属性的属性值双引号不能丢), 传递指令解析后得到的最终属性值给子组件, 在子组件中接收时, 直接使用未转化成指令的标签属性名接收即可
    //          4. 单项数据流: 父组件中引入子组件并将数据传递给子组件, 若父组件中在视图自动渲染过程中原来传递给子组件的数据发生改变了,
    //             则父组件会★自动★将更新后的数据传递给子组件 (若是引用数据类型的, 即使引用地址不发生改变, 只要引用地址里的数据发生改变, 就会重新传递改变后的数据给子组件, 与引用地址是否改变无关), 子组件会自动根据父组件传递过来的改变后的数据, 自动重新渲染更新dom树 并自动更新页面, 自动渲染 并展示
    //          5. ★ 父组件可以向子组件传递任意数据类型的数据 (5简单3复杂) (标签属性的属性值双引号不能丢)
    
    // 拓展: 如果给子组件使用处的标签加上ref属性, 则将来vue实例$refs中存储着就是子组件的vue实例了, 而组件的methods方法都在vue实例身上,
          // 所以我们在父组件中就可以通过refs中子组件vue实例.子组件函数名(), 来调用子组件中的方法了 (在子组件的方法中, this指向子组件vue实例), (在父组件中调用子组件方法) 并且可以将父组件中的数据作为实参传入, 将来在子组件函数中通过形参
          // 按顺序一一对应接收, 这样在子组件中也可以拿到父组件传递的数据了, 并且可以在子组件中使用父组件中的数据 (因为调用的子组件中的函数, 函数在子组件中声明的)
          // 然后在调用完子组件定义的函数后, 会重新回调函数调用处, 也就是父组件中, 继续往下执行后面的代码. (同步调用)
    
    const vm = new Vue({
      el: '#app',
      data: {
        msg: '这是 Vue 实例提供的数据'
      },

      components: {
        hello: {
          template: `
            <div >这是 Hello 子组件 -- {{ ppp }} | {{ gender }} | {{ parentmsg }}</div>
          `,

          // 通过 props 属性，来指定该组件接受的数据
          // props 的使用方式与 data 相同
          props: ['ppp', 'gender', 'parentmsg'],
          data() {
            return {
              
            }
          }

          }
        }
      })
  </script>
</body>

</html>
