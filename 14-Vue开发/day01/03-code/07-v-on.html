<!DOCTYPE html>
<html lang="en">
  <head>
    <title></title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="./vue2.js"></script>
  </head>
  <body>
    <div id="app">
      <h1>{{name}}</h1>
      <!--
        给标签注册事件使用v-on指令(支持指令的所有特性)：语法: v-on:事件名="函数(引用地址)" (双引号必须有, 因为指令是标签属性) 这个事件名也可以自定义
        这里只是声明函数, 不会执行函数体

        ps: 指令可以直接通过函数名, 获取vue实例methods中的函数(引用地址)

        注册事件时的函数又称为事件处理函数(只是换了个称呼而已), 注册事件不会调用事件处理函数, 要等到事件触发时, 才会调用事件处理函数
        注册事件时候, 事件处理函数相当于声明函数, JS不会解析和执行事件处理函数中的代码, 而是在注册上事件后, 直接跳过, 要等到调用时, 才会去解析和执行事件处理函数中的代码, 函数体中的数据以调用函数执行函数体时的值为准
        一个事件可以被触发多次, 每次触发, 都会调用 一次 对应事件的事件处理函数
        只要是触发了事件, 都会调用对应的事件处理函数

        一个标签元素可以同时绑定多种类型的事件, 在标签属性里写多个@事件名="函数(引用地址)"即可

        如果事件处理函数为简单的JS表达式或函数调用, 则可以简写为 v-on:事件名="表达式或函数调用", 并且v-on是指令, 所在也支持指令的所有特性

        特殊: 绑定的事件处理函数一般都在methods中, 而methods中的函数的this都指向vue实例, ★ 所以vue中事件处理函数中this不再指向注册事件的dom元素了, 而是指向vue实例
        //    如何解决? : 后续使用ref属性, 通过vue实例也可以拿到dom元素

        v-on简写: @
        简写： @事件名="函数(引用地址)"⭐
       -->
      <button v-on:click="changeName">点击改变</button>
      <button @click="changeName">点击改变简写</button>
      <!-- 传参, 在指令中, 这里不是调用函数的意思, 参数可以传多个 传递的参数会在事件处理函数中按顺序一一对应接收 -->
      <!-- @事件名="函数(实参列表)" , 将来在定义事件处理函数的时候, 通过定义形参按顺序一一对应接收-->
      <!-- 在绑定事件时传参, 若后续视图更新渲染, 如果传参的值发生改变, 则对应的事件处理函数传参的值也会自动发生改变  -->
      <button @click="changeNameByArg('黑马程序员')">点击改变传参</button>
      <!-- 注意如果想要传递事件对象，就只能写$event，并且不能加引号 -->
      <button @click="getEvent($event)">点击获取事件对象</button>


      <!-- 事件修饰符：用来增强事件功能，常用的有.stop 阻止事件冒泡 及.prevent 阻止默认行为 -->
      <!-- 修饰符可以同时写多个, 直接点.下去就好, 比如.stop.prevent.13, 都会同时起作用 -->
      <a href="http://www.baidu.com">跳转到百度</a>
      <a href="http://www.baidu.com" @click.prevent="print">打印一句话</a>

      <!-- 按键修饰符, 键盘事件(keyup, keyDown, keyPress)特有 -->
      <!-- 在键盘按下特定按键时, 才会调用事件处理函数 -->
      <!-- 通过键盘码修饰 -->
      <input type="text" v-model="name" @keyDown.13="submit">
      <!-- 通过按键别名修饰 -->
      <input type="text" v-model="name" @keyDown.enter="submit">
      <!--
      .enter
      .tab
      .delete (捕获“删除”和“退格”键)
      .esc
      .space
      .up
      .down
      .left
      .right
      -->
    </div>
    <script>
      var vm = new Vue({
        el: '#app',
        data: {
          name: 'itcast',
        },
        // vue中规定, vue实例中所有定义(声明, 创建)函数都在methods对象的属性中定义(推荐使用es6对象中函数属性简写形式), 可以声明多个, methods中都是函数的声明, 不会调用
        // methods是一个对象, 内部只用来声明函数, 推荐使用es6对象简写函数属性的方式
        // ★ 在vue实例methods属性中的所有函数, 他们的函数体中的this都是指向vue实例对象
        // 而vue实例对象中, 所有的data中的变量及其值, 都会保存一份到vue实例对象的属性上(变量名与值和data中一致), 并且始终保持他们是实时同步且一致的, 即只要其中某一个变, 另一个也会自动跟着一起变, 始终保持一致 , 且是实时 ★同步★立刻更新的, 实时同步保持一致
        // methods中声明的函数, 实际上是存储在vue实例对象的属性里, 属性名为函数名, 值为函数, 并且会始终自动保持与methods中定义的函数一致, 即也会同步更新
        // 我们可以直接通过vue实例.变量名访问到data中的数据; vue实例.函数名访问到methods中的函数 (引用地址)
        // 我们也可以直接通过vue实例.变量名 = 值 (一般都这么用) 给vue实例中拷贝的data变量★同步★赋值, ★ 且赋值会实时同步立刻更新到data中的对应变量, 即可以给data中的变量赋值  并且页面会自动重新更新渲染 ; vue实例.函数名 = 函数 (引用地址) (一般不这么用) , 
        // 由以上可以知道, 我们可以把data中拷贝到vue实例中的变量 和 data中存储的变量 看作 同一个东西, 因为他俩是实时同步且一致的, 一个变, 另一个也会自动跟着一起变, 始终保持一致, 且是实时 ★同步★立刻更新的, 实时同步保持一致, 并且页面会自动重新更新渲染
        // 所以我们在methods中的函数的函数体中, 可以通过this.变量名 直接访问到 data中的数据, 通过this.函数名 直接访问到methods中的函数 (引用地址, 调用的话要加括号())
        // 所以我们在methods中的函数的函数体中, 可以通过this.变量名 = 值, 赋值会同步更新到data中的对应变量, 来给data中的变量赋值

        // 总结:
        // 在methods的函数的函数体中,
        //        1> 访问/获取data中的变量, 直接通过this.变量名即可;  同步获取
        //        2> 给data中的变量赋值, 直接通过this.变量名 = 值 即可; (如果是对象属性, this.对象变量名.对象属性名 = 值,  可以给data中的对象变量中的属性值赋值(添加或修改属性) 同步赋值 数据同步更新
        //        3> 访问/获取methods中的函数(引用地址), 直接通过this.函数名即可, 获取到函数的引用地址后可以直接加 () 调用 ( ★ 同步调用).
        //           同步获取
        //        4> 给methods中的函数赋值, 直接通过this.函数名 = 值 即可 (一般不会去修改methods中的函数的值) 同步赋值 数据同步更新
        // vue在所有可以获取到vue实例的地方,
        //        1> 访问/获取data中的变量, 直接通过vue实例.变量名 即可; 同步获取
        //        2> 给data中的变量赋值, 直接通过vue实例.变量名 = 值 即可; (如果是对象属性, vue实例.对象变量名.对象属性名 = 值,  可以给data中的对象变量中的属性值赋值(添加或修改属性) 同步赋值 数据同步更新
        //        3> 访问/获取methods中的函数(引用地址), 直接通过vue实例.函数名即可, 获取到函数的引用地址后可以直接加 () 调用 ( ★ 同步调用).
        //           同步获取 
        //        4> 给methods中的函数赋值, 直接通过vue实例.函数名 = 值 即可 (一般不会去修改methods中的函数的值)
        //           所有访问/使用/获取性的操作, 访问/使用/获取的都是当前获取性代码执行时, 内存里此刻存储着的对应获取数据的值 同步赋值 数据同步更新

        // ★★★ 因为vue实例中拷贝的data中变量 和 data中的变量 实时 同步 时刻 更新 保持一一对应且一一相等的关系, 则我们可以认为 vue实例中拷贝的data中的变量 就认为是 data中的变量, 操作vue实例中的拷贝的data数据实际就是操作data中的数据, 因为会实时同步更新 !!!  并且页面会自动重新更新渲染 ★★★
        // ★★★ 不仅仅是赋值, 其他所有操作, 只要改变了vue实例中拷贝的data中的数据, 就会自动立刻同步更新到data中.  并且页面会自动重新更新渲染 

        // 视图中有用到函数调用的, 会自动监听函数体, 若函数体中使用到的数据发生变化, 导致返回值发生变化, 则页面会自动重新调用函数, 获取最新的返回值, 重新渲染页面
        methods: {
          changeName () {
            // 改变name的值
            console.log(111);
            console.log(this.changeNameByArg)
            console.log(this)
            // 这里的this就是指vue的实例
            console.log(this === vm);
            this.name = 'heima'
          },
          changeNameByArg(newName) {
            this.name = newName
          },
          getEvent(e) {
            console.log(e);
          },
          print() {
            console.log('阻止你跳转');
          },
          submit() {
            console.log('你提交了表单');
          }
        }
      })
    </script>
  </body>
</html>
