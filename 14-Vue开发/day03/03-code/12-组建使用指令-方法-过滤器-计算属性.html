<!DOCTYPE html>
<html lang="en">
  <head>
    <title></title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="./vue2.js"></script>
  </head>
  <body>
    <div id="app">
      <index>

      </index>
    </div>
    <script>
      // 不管是全局组件还是局部组件, 都可以使用原来的data, methods, computed, 等其他vue中的功能,
      // 但是这些数据和功能的使用范围是在该组件的视图中, 即template模板中使用, 在别的地方无法使用, 各个组件的数据是互相独立的
      // 唯一有不同的就是 data属性了, 是一个函数, 并且要返回一个全新的对象, 避免不同组件之间的数据互相影响, 对象中的数据就是data中的变量了
      // 注意, 一个组件可以复用多次, 复用的组件中, 每个组件又是互相独立的, 互不影响, 数据不共享, 即每个组件中的数据data, methods, computed.. 等所有数据, 都是互相独立的, 互不影响, 数据不共享, ⭐
      // 因为在每次复用组件时, 都会重新初始化该组件, 放到独立的内存里, 所以各个组件中的数据都是互相独立的, 互不影响的, 数据不共享, ⭐
      // 各个组件中的数据相互独立, 数据不共享, 互不影响, 只能在各自组件中使用, 在各个组件中操作和使用、访问数据, 都是操作和使用、访问自己这个组件中的数据 .
      // 每个组件其实就是一个vue实例, 都拥有vue的生命周期, 以及钩子函数, 各组件间的钩子函数互相独立, 数据不共享,只能在本组件中起作用
      // vue实例或组件中可以多次使用组件
      // 组件的视图模板, 就是页面部分, 将来展示到页面中的部分

      // ★★★ 组件多次使用, 每次使用都会重新创建一个新的组件, 包括数据初始化, 以及视图初始化, 以及钩子函数重新执行等, 且多次使用组件之间是互相独立的, 互不影响, 互不干扰


      // 所有组件的template就是该组件vue实例对应的管理范围, 所以在组件的template中vue实例特性均可以拥有/使用和生效, 各个组件中数据互相独立, 不共享, 不影响 数据只能使用本组件中的数据.


      // 之前所说的所有函数中, this指向vue实例的, 在组件中, this仍指向vue实例, 且指向的是此函数所在组件对应的vue实例, 即指向各自的组件vue实例. 各个组件都是相互独立的和封闭的, 数据不共享, 每个组件都是一个vue独立的实例, 都是不同的vue实例
      // 在各个组件中, 若this指向的是vue实例的, 指向的都是各自所在组件的vue实例

      // 组件也相当于是vue实例, 也具有自动渲染, 双向绑定, 数据驱动功能, 只不过组件的视图是各自组件的template模板
      // ★★★ 组件其实就是一个vue实例 vue实例其实也是一个组件
      // 组件其实就是vue实例, 所以在组件的视图模板template中, 相当于是vue的管理范围内, 也可以使用, 拥有之前所有的vue特性, 比如插值表达式, 指令, 数据更新视图自动渲染, 双向绑定等所有vue特性
      // 组件其实就是一个vue实例, 也 ★ 具有vue中所有的特性, 包括插值表达式, 指令, 自动渲染, 双向绑定, methods, 计算属性, data等等所哟vue实例的用法, 都与之前学习的vue实例一致
      // 使用组件, 会将组件中的模板视图编译渲染后 替换并 渲染到 组件使用处, 并且该部分视图由组件内部vue实例自己维护, 包括自动渲染等所有vue特性


      // ★ 在组件中(不管是全局组件还是局部组件), 都可以使用其他组件(不管是全局组件或局部组件)

      // ★★★ 在组件中引入其他组件, 由于引入组件都是以标签的方式引入的, 所以使用组件的标签中也可以使用vue特性. 因为组件是在视图中引入的, 在视图中就可以使用vue特性

      // 组件总结:
      // 1. 组件(全局组件和局部组件), 也是一个vue实例 (js对象), 组件不需要el属性, 组件的对应的视图为template模板
      // 2. 因为组件也是vue实例 (js对象) , 所以也含有之前vue实例的所有特性, data(必须返回一个新的对象), methods, computed 以及它们的原理拷贝特性以及访问方式等, 插值表达式、指令..以及视图自动更新渲染, 数据驱动, 双向数据绑定, MVVM等所有其他vue实例中含有的数据和特性, 在组件中都可以使用
      // 3. 组件可以复用多次, 且复用的各个组件之间, 数据都是互相独立的, 数据不共享, 互补干扰的, 互不影响的, 相当于每次复用, 都会创建一个新的组件, 与之前的组件互不干扰, 相互独立, 数据不共享,
      // 4. 各个组件间的数据互相独立, 组件中的数据只能在各自组件的视图模板中使用, 即作用范围仅限于当前自己组件中使用, 组件的视图模板template中, 获取和使用到的数据也都是当前组件中的数据
      // ★ 组件的template视图中也和原来vue实例一样, 只有插值表达式和指令会被解析和执行, 其他都当作标签或者普通文本. template用来写html标签的, 其实就是html标签, 写法和原来html标签一样 包括给标签添加类名class, 行内样式style, 都可以直接在标签上写, 和原来一样.. 
      // ★ 组件之间的数据互相独立, 组件中的数据只能在当前组件中使用, 即只能在当前组件的视图模板中使用.
      // 5. 组件中的函数中所有this指向vue实例情况, 都只是指向当前函数声明所在组件的这个vue实例
      // 6. 使用组件时, 会将组件中的模板视图template渲染后替换掉使用组件处标签引入, 且会更新到dom树上, 渲染到页面上
      // 7. 组件会维护自己的视图, MVVM, M： 自己组件中的数据, V: 自己组件的视图模板template VM: 双向绑定, 自身组件内数据变化, 会自动渲染视图template, 然后将渲染后的视图更新到组件使用处dom并重新渲染页面
      // 8. ★ 组件引入其他组件, 引入的是完整的组件, 即若引入的组件中也引入了其他的组件, 则也会编译后一起引入, 即保持原组件的完整性
      // 9. 组件的生命周期以及钩子函数, 与vue实例中的一致, 使用组件, 也会先创建组件vue实例, 然后经过生命周期初始化, 将最后得到的渲染后的模板视图template替换掉组件使用处, 渲染到页面上
      // 10. 各个组件之间, 数据都是互相独立, 互不干扰的, 数据不共享,
      // 11. ★ 在组件中(不管是全局组件还是局部组件), 都可以使用其他组件(不管是全局组件或局部组件), 且只能在组件的template模板中使用, 可以多次, 多个使用组件
      
      // ★ 组件中不需要指定el属性, 将来组件中的模板视图会在使用组件处替换并渲染到页面上
      // ★ 各个组件中的数据是互相独立的, 互不影响的, 包括复用组件, 父子组件. 兄弟组件等所有组件, 数组都是独立的, 不共享, 无法互相访问



      // 1.1 假设创建一个product局部组件
      let product = {
        template: `
        <div>
          {{msg}} {{company}}
          <button @click="change">改变</button>
          <input type="text" v-focus/>
          <div>{{ctime | fmtTime}}</div>
          <div>{{ctime | fmtMonth}}</div>
        </div>
        `,
        // data 必须是一个函数了，并且要返回一个全新的对象, 必须是要返回一个全新创建的对象!!! 避免不同组件之间数据互相影响, ⭐
        data() {
          return {
            msg: 'hello world',
            ctime: new Date()
          }
        },
        methods: {
          change() {
            this.msg = 'hello 黑马'
          }
        },
        computed: {
          company() {
            return '传智播客'
          }
        },
        // 局部自定义指令通过directives创建, 这个指令只能在当前这个组件中使用，脱离了就使用不了, 在其他组件中使用不了
        // directives中可以创建多个自定义指令, 定义和用法同全局自定义指令一致
        directives: {
          focus: {
            // 指令的定义
            inserted: function (el) {
              el.focus()
            }
          }
        },
        // 局部过滤器通过filters创建，这个过滤器只能在当前这个组件中使用，脱离了就使用不了, 在其他组件中使用不了
        // directives中可以创建多个过滤器, 定义和用法同全局过滤器指令一致
        filters: {
          fmtTime(time) {
            let y = time.getFullYear()
            return y
          },
          fmtMonth(time) {
            let y = time.getMonth() + 1
            return y
          }
        }
      }

      Vue.component('index', {
        // 1.3 在index组件的模板中使用product组件
        template: '<div>这是首页:<product></product></div>',
        // 1.2 如果想要使用下面的product，得在index组件中注入一下，通过components属性注入
        components: {
          product
        }
      })


      console.log(product)
      var vm = new Vue({
        el: '#app',
        data: {

        }
      })
    </script>
  </body>
</html>
