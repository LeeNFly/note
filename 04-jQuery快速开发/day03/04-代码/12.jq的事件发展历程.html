<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        div{
            width: 300px;
            height: 300px;
            background-color: #f99;
        }
        p{
            padding: 10px;
            background-color: #ccc;
        }
    </style>
</head>
<body>
    <button id="created">点击创建p元素，添加到div内</button>

    <div>
        <p>这是div内的p元素</p>
    </div>
    <p>这是div外的p元素</p>
    <br>
    <br>
    <br>
    <br>
    <button id="unbind">解绑元素的事件</button>

    <script src="./jquery-1.12.4.js"></script>
    <script>
        $(function(){
            // 在js中 注册事件只有2种方式: 使用on注册事件, 使用addEventListener (有兼容性问题)
            // jQuery对js事件进行了封装, 增加了事件处理机制, 提升了事件的处理能力

            // 说明:
                // 1 使用jq注册事件, 一个元素同类型事件可以注册多个, 不会覆盖原来的事件处理函数 相当于追加 并且没有兼容性问题
                // 2 使用jq注册事件, 会把jq对象里的所有元素都注册相同的事件
                // 3 使用jq注册事件, 事件处理函数中的this, 与WEBAPI中一样, 当前执行的事件处理函数是哪个元素注册的, this就指向这个元素, ★ this是dom元素
                //   ps: 会把jq对象里的所有元素都注册相同的事件和事件处理函数, 本质上底层还是通过遍历jq对象中的dom, 给每个dom单独注册事件,
                //        所以看似是批量注册, 实际上还是单个单个注册的, 所以事件处理函数中的this就是指向每个注册事件的dom元素,  所以事件处理函数中的可以把每个元素区分开来 在调用执行事件处理函数的时候, 解析执行的时候, this会被解析成注册 (当前执行的事件处理函数) 的那个dom元素,
                // 4 只要事件绑定代码执行后, jq对象中的元素就注册上了事件
                // 5 jq中注册事件, 不需要再加on了
                // 6 jq注册事件的事件处理函数也是匿名函数, 是函数 (引用地址)
                // 7 jq事件处理函数也支持外提  所有的匿名函数都支持外提
                // 如 jq对象.事件名(function() {}) => jq对象.事件名(fn) fn是一个函数,   function fn() {};
                // 8 jq 事件处理函数中 多用this
                // 9 jq对象可以绑定多个不同类型的事件
                // 10. 注册事件不会调用事件处理函数, 要等到事件触发时, 才会调用事件处理函数
                // 11. 一个事件可以被触发多次, 每次触发都会调用执行 一次 对应事件的事件处理函数,执行事件处理函数的函数体,拿到的数据都是最新的
                // ps: 只要是触发了对应的事件, 都会调用对应事件的事件处理函数
                // ps: 对于h5新增的事件, 在jq中都需要通过on来进行注册事件
                // ps: 注册事件不会执行事件处理函数, 等到事件被触发时候, 才会调用事件处理函数, 执行函数体, 函数体中的数据以调用事件处理函数时为准
                // ps: 事件处理函数执行完毕后,数据不会消失,而是继续存储在对应内存中,对于相同作用域内声明同名的变量,后声明的变量会把之前声明的变量覆盖
                // ps: 注册事件的时候, 事件处理函数,相当于函数的声明,JS遇到时不会解析和执行里面的函数体中的代码,而是在注册上事件后, 直接跳过,等到事件被触发的时候,才会调用函数,才会去具体解析和执行函数体,函数体中各个变量的值以调用函数执行函数体的时的值为准,即以事件触发时/函数调用时/执行函数体时 为准
                // ps: 以下注册事件时的函数, 又称为事件处理函数 (只是换了个称呼而已) , 都只是声明函数, 不会执行函数体

            // 以事件名的方式注册的事件
            // jq对象.事件名(function() {});
            // 会把jq对象里的所有元素都注册相同的事件

            // mouseenter()

            /*$("p").click(function(){
                console.log("你们现在困吗？");
            })*/

            // 使用jq注册的事件不会覆盖的问题
            /*$("p").click(function(){
                console.log("嗨起来");
            })*/

            // 以事件名的方式注册的事件存在的缺陷： 由于jq注册事件不会覆盖原来的事件, 所以无法解绑, 因为此方法注册同类型事件不会覆盖
            // $("p").click(null); // 无法解绑


            // jq对象.bind()：   unbind()： 解绑
            // jq对象.bind(type, fn);
            // type:  事件名字符串， 可以使用空格隔开，注册多个事件
            // fn： 事件处理函数
            /*$("p").bind("click mouseenter", function(){
                console.log("你们现在困吗？");
            })*/
            /*$("p").bind("click", function(){
                console.log("皮一个");
            })*/

            // 解绑事件
            // jq对象.unbind() 解绑jq对象中所有元素的所有类型的事件;
            // jq对象.unbind('事件名') 解绑jq对象中所有元素该类型事件下注册的所有同类型事件; 可以一次解绑多个类型事件, 使用空格隔开
            /*$("#unbind").click(function(){
                // 解绑了元素注册的所有类型下的所有事件
                // $("p").unbind();

                // 指定事件名，解绑对应的事件, 会解绑该元素注册 同类型 的所有事件, 比如注册了多个点击事件, 会把所有点击事件都解绑
                $("p").unbind("click");
            })*/


            // 创建p元素
            $("#created").click(function(){
                // 创建p元素
                $("<p>这是创建的p元素</p>").appendTo("div");
            })

            // bind注册事件存在的问题：不支持动态绑定, 即新增的节点没有被绑定事件



            // delegate()  ： 注册委托事件， 用来解决 动态绑定, 让注册事件时, 当前存在(指定)子节点的以及当前不存在的, 但是后续新增的(指定)子节点(动态生成的, 动态渲染的) 子节点, 也注册上相同的事件, (当事件触发时, 也可以调用事件处理函数) (注册事件委托的父元素一般不是动态生成的)
            // 事件委托： 把事件注册给父元素，让指定的子元素或后代元素去触发, 只能由父元素的子元素触发，(注册事件委托的父元素一般要求不是动态生成的) 原理：事件冒泡
            // ★ 虽然父元素不能触发delegate注册的事件委托, 但是可以给父元素自己注册同类型事件, 父元素的事件委托和自己注册的事件是不会冲突的
            // jq对象(父元素).delegate(selector, type, fn) 会把jq对象中的所有元素都注册上事件委托
            // selector: '选择器', 表示有指定的子元素或后代元素来触发事件, '选择器', 指定了由哪些子元素触发, 这里的选择器是在后代元素中过滤, 支持复合选择器, 子后代等 比如 .box span
            // type： 要注册的事件类型 是'事件名'
            // fn： 事件处理函数

            //注意: 注册的事件委托父元素自己是不能触发的, 只能让其指定的子元素或后代元素去触发. 但是这个事件是算父元素注册的事件,是注册在父元素身上的 而不算子元素注册的
            // ★ 虽然父元素不能触发delegate注册的事件委托, 但是可以给父元素自己注册同类型事件, 父元素的事件委托和自己注册的事件是不会冲突的
            // 不管是父元素的事件委托, 还是子元素的事件委托, 都与元素本身的事件没有冲突
            // 子元素注册事件委托后, 还可以给自己注册相同类型的事件, 相当于追加 不会冲突 是2个不同的事件
            // ★★★ 只有jq 事件委托事件处理函数中的this 比较特殊, 指向当前触发事件的子元素, 是一个dom元素. ; 其他事件处理函数中的this都是 当前执行的事件处理函数是谁注册的, this就指向这个元素 是一个 dom元素

            // 注意: 使用事件委托给新增的子节点绑定事件时, 由于事件处理函数不是立即调用, 要等到事件触发时才会调用, 且函数的调用函数体中的数据是以调用函数, 执行函数体时为准
            //      而事件触发时, 页面基本已经动态渲染完成(动态渲染的标签已经添加到dom树上了), 此时触发事件, 调用事件处理函数, 在函数中已经可以获取的到页面中的所有元素
            //


            $("div").delegate("p", "click", function(){
                console.log("这是delegate 注册的委托事件");
            });

            // jq对象(父元素).undelegate():  用来解绑事件委托 会把jq对象中的所有元素下的所有事件类型的事件委托都解绑
            // 事件委托 是 通过 父元素来解绑的
            // 注意: 解绑事件委托,是给父元素解绑事件委托, 只会解绑父元素的事件委托, 不会解绑子元素本身的同类型事件, 也不会解绑父元素本身非事件委托的相同类型事件
            $("#unbind").click(function(){
                // 解绑元素所有的事件委托
                // $("div").undelegate();

                // 解绑指定的事件委托 解绑jq对象中所有元素下的指定子元素的指定事件类型下的所有的事件委托

                // 参数1： 指定的元素
                // 参数2： 事件类型
                $("div").undelegate("p", "click");
            })

        })
    </script>
</body>
</html>
