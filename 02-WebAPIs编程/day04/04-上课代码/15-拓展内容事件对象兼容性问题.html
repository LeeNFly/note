<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<body>
  <script>
    // 事件对象兼容性问题
    // var link = document.getElementById('link');
    // 1. ie8中,浏览器不会把事件对象,传递到事件处理函数中,而是把事件对象绑定到了window的event属性上面
    // 兼容性写法
    // link.onclick= function(e){
    // e = e || window.event; //兼容性的写法
    // }


    // 2. ie8及以前事件对象不支持target,使用srcElement代替
    
    // link.onclick= function(e){
    //   e = e || window.event; //兼容性的写法
    //   console.log(e.target); // 在ie8中是undefined
    //   console.log(e.srcElement); //兼容性写法, 返回目标元素
    //   return false;
    // }

// 一.逻辑运算符 的返回值(得到的值) 和 执行逻辑: 
//    A 和 B 可以是确定的值, 变量的值, 或者是表达式或者函数的调用
//  1.  A && B 
//     1) 如果A和B是确定的值, 变量的值, 
//        先将A隐式转为布尔值, 若为false, 则直接返回A(未转布尔前的值), 否则返回B.
//     2) 如果A和B是表达式或函数的调用
//        先执行A, 如果得到的结果A1隐式转为布尔值为false, 则直接返回A1(未转布尔前的值),不会执行B
//        如果执行A得到的结果A1隐式转为布尔值是true, 则再执行B, 并将执行B得到的结果直接返回
//  2. A || B
//     1) 如果A或B是确定的值, 变量的值, 
//        先将A隐式转为布尔值, 若为true, 则直接返回A(未转布尔前的值), 否则返回B.
//     2) 如果A和B是表达式或函数的调用
//        先执行A, 如果得到的结果A1隐式转为布尔值为true, 则直接返回A1(未转布尔前的值),不会执行B
//        如果执行A得到的结果A1隐式转为布尔值是false, 则再执行B, 并将执行B得到的结果直接返回
	
//  3. !A 
//        如果A是确定的值, 将A转化为相反的布尔值, 并返回这个布尔值; 如果A是函数或者表达式, 先执行A, 将得到的结果转化为相反的布尔值, 并返回这个布尔值 
//        ps: 逻辑运算符! 返回的是一个布尔类型的值

// ps: 以上1. 2. 只是两个项的逻辑运算符的返回值规则。如果是多个项并且&& || 混合使用, 
//     则可以根据以上规则, 从左到右, 两两判断, 将得到的返回值再与下一个进行判断, 
//     又得到一个返回值, 再与下一个进行判断…. 直到与最后一个进行判断,  最后可以得到一个返回值,  
//     比如: console.log(0 && 3 || 7 && 9 ) // 9

//     拓展: 
//           如果逻辑运算符的每一项都是布尔值(如果是表达式或函数调用的, 则要求得到的最后结果是布尔值), 
//           那么可以根据以下规则快速的得到最后的返回结果, 且与1. 和 2. 的执行结果一致
//            1)&&: 一个为布尔值false则返回布尔值false, 两个为布尔值true, 则返回布尔值true
//            2) ||: 一个为布尔值tue, 则返回布尔值true, 两个为布尔值false, 则返回布尔值false
//            ps: 以上两条支持多个 
//            3) 对于&& 和 || 混合使用的, 从左到右, 两两判断, 将判断的结果在与下一个进行判断, 最后得到一个布尔值, 返回
//     拓展说明: 
//           1) 此规则要求逻辑运算符的每项都是布尔类型
//           2) 是基于以上1. 2. 的规则, 所以最后的结果与按照1. 2. 进行执行得到的返回值一致. 不会冲突, 是符合1. 2. 是规则的
//           3) 仅可以用此方法快速的得到最后的返回值, 但是无法直到哪些表达式或函数调用是执行了的, 哪些是没有执行的. 
//           4) 如果想要知道具体哪些是有执行, 哪些没有执行,则需要根据1. 2. 一步步比较才能知道


// 二. 隐式布尔类型转换: 
//      当条件中最后结果需要是布尔值的, 比如 if 、 三元运算符、 while 、 do .. while、 for循环, 这些条件可以是具体的值, 也可以是变量的值, 表达式或函数的调用, 
//      如果条件中的值或者最后的结果不是布尔类型的话, 会 ★ 自动进行隐式布尔类型转换, 将条件最后的值隐式转化为布尔值,
//      并且根据隐式布尔类型转换的结果, 来执行对应的代码块 ps: 布尔类型的值隐式转布尔还是本身

// 三. 在 if 、 三元运算符、 while 、 do .. while、 for循环 的条件判断中 (这些条件可以具体的值, 也可以是变量的值, 表达式或者函数的调用), 
//     隐式布尔类型转换、逻辑运算符可以一起配合使用:
//    1. 原理方法: 
//          先根据逻辑运算符的返回值规则,  先执行所有逻辑运算符, 拿到逻辑运算符返回的最后结果,
//          再将逻辑运算返回的最后的结果进行隐式布尔类型转换, 最后根据隐式布尔转换的结果执行对应的代码
//    2. 出现的问题: 
//          但是这样不利于我们直接判断到底执行哪个代码, 可以有通过以下方法快速的知道逻辑运算的结果最后隐式布尔转换的结果, 
//          这样就可以快速的知道执行哪个代码了:
//    3. 简便方法: 
//          将逻辑运算符中的每一项(如果是表达式, 或函数, 则直接取最后的结果, 注意没有执行, 只是理论结果; 如果是变量, 则取变量的值) ,
//          把不是布尔类型的都隐式转化为布尔类型, 然后将这些布尔类型根据 :
//            1)&& 一个为false就为false， 全部为true才为true
//            2)||  一个为true则为true, 全部为false, 则为false
//            ps: 1) 和 2) 支持多个
//            3)&& 和 || 混用的, 从左到右两两判断, 将得到的结果再与下进行判断,最后可以得到一个布尔值
//       说明:
//            通过以上的方法, 可以快速知道判断条件中逻辑运算的最后结果, 最后隐式转换成布尔类型的结果是什么,
//            即快速的知道最后的隐式转换结果是什么, 并且这个结果与通过原理方法得到的隐式转换结果一样, 不冲突的, 这样我们就可以快速的知道要执行哪个代码块了.	 
//            但是具体的逻辑运算符中如果有表达式或函数的, 我们就没法知道哪些是执行了的, 哪些是没有执行的, 如果要想知道, 只能通过原理一个个去比较了.
    console.log(!1);
    
    
  </script>
</body>
</html>