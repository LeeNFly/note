<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>
//  一个html页面中的所有内容都是节点 标签节点(重点),文本节点,属性节点,注释节点...   节点也是一个对象  是对象类型
//  当浏览器加在一个html页面的时候,会把页面中(html标签中的)的所有内容加载到内存中(加载到DOM树中),按照他们的关联关系组织管理起来.他们的这种关联关系,看起来像一棵树.所以我们把他们在内存中的存储形式称之为是DOM树. (dom树中存储着各种各样的节点, 如 标签节点(重点),文本节点,属性节点,注释节点...   节点也是一个对象  是对象类型)
//  然后浏览器再根据dom树,去渲染生成页面.把dom树上有用的信息,渲染出来.
// 特别说明：
//  1) 元素就是标签节点, 标签节点就是元素. 我们只研究标签节点, 只研究元素
//  2) 像文本节点, 属性节点, 我们不研究, 因为这些都是可以通过标签节点, 也就是元素来操作的.

// ★ 结论:如果元素在dom树上,浏览器会渲染,不在dom树上就不会渲染出来, 并且浏览器会自动维护dom树及dom树上的节点
// ★ 结论:只要是DOM树上的(标签节点),也就是元素,JS dom就能获取的到该标签节点 (元素) , 如果元素不在dom树上, js dom就获取不到元素
//   后续动态添加到DOM树上的节点也能被获取到, 只要当前获取元素操作执行时, DOM树上有该标签节点, 就能获取的到, 若当前获取DOM元素时, DOM树上没有该标签节点, 则就获取不到
// ★ 结论:通过JS获取到的元素, 一定在dom树上.
// ★ 结论:如果dom树上的元素(标签中)中相关属性, 样式, 类名, 子后代html结构, 文本等发生改变,浏览器也会自动立即重新渲染dom树 即重新渲染页面, 浏览器会立即自动维护和渲染在dom树上的标签
//        浏览器会自动维护dom树上的节点
//        对于会改变元素属性，类名，文本，html结构等的dom操作, 如果元素在dom树上, 则浏览器会自动维护, 会自动渲染.
//        对于改变类名的操作, 若类名有涉及相关的css, 且元素在zom树上, 则会重新渲染
//    页面中的html标签一开始加载的时候就在dom树上, 浏览器加载页面的时候会把页面的html标签等全部加入dom树
//  ★ 只有标签节点 ★ 才是之前说的元素, dom元素, dom对象,是一个对象. 在JS中,元素就是html中的标签, ★★★ 其他类型的节点都不是元素
//  ★ 元素 就是, 仅是 标签节点.

// display: none; 元素及其内部元素还在dom树上(保存了html结构, dom结构), js能获取到该元素及其内部元素, 并且操作该元素, 给该元素绑定事件等, 同时该元素因为隐藏了, 无法用鼠标去触发该元素的事件, 但是js代码仍可以触发该元素的事件
//                不占位置隐藏,隐藏后不会占标准流位置, 保留html结构和原有的位置和顺序不变(不会改变标签的顺序), 不影响功能.
//                 等到重新显示时, 就会重新占标准流位置
// ps: 通过document.get...获取页面元素的6个方法, 只能获取在dom树上的元素
//     但是对于支持element.get..获取元素的4个方法: 如果元素在dom树上, 则以dom树的结构进行获取. 如果元素不在dom树上, 是新建的, 则以新建的元素自身的结构进行获取

// ★★★ ps: dom中, 除了通过document来获取页面元素, 只能获取在dom树上的元素外,
//          对于其他dom中的方法, 与元素是否在dom树上无关, 都可以使用, 如果元素在dom树上, 浏览器就会自动对我们的操作进行渲染, 如果元素不在dom树上, 等到元素加到dom树上, 浏览器再为我们渲染

// 浏览器工作原理说明:
// 浏览器会对html, css 代码进行解析和渲染, 对js代码进行解析和执行
// 浏览器对页面的解析和执行的顺序是从上往下解析和执行的, 包括html, css, js等其他.
// 1. dom树,规则树,以及渲染树,都是加载存储在内存中的
// 2. js对dom树, css规则树以及渲染树的操作,比如改变dom树htm结构,或者改变dom树上dom元素(标签节点)的样式或html结构等所其他操作都会同步保存在内存中, 除非页面重新加载(刷新页面或跳转页面)
// 3. js中声明的变量，函数,以及其他所有数据,都是一直存储在内存中的，对数据的操作,比如赋值等所有其他操作，都会一直保存在内存中,除页面重新加载(刷新页面或跳转页面)
// 4、js中所有声明的数据(变量, 5基本, 3复杂等所有数据), 都是一次声明, 多次使用的
// 5、js中,所有访问/使用/操作/获取性等所有操作,获取的都是访问/使用/操作/获取当前执行获取性操作这段代码时，内存中此刻保存的对应的要获取的那个数据的值, 并且要等到获取到值之后, 才继续执行后面的操作, 代码..
// 6、js中,所有的代码执行都是 立即 同步 生效的, 会先立刻把代码执行的影响立刻 同步 保存在内存里且生效, 之后再往下执行下一行代码 ... , 后面执行的代码都是基于之前执行的代码
// 7. js中, 只要没有说是异步的, 则都是 ★ 同步执行的, 即会阻塞栈, 即要等到上面的代码执行完毕后且★代码执行的影响保存更新到内存后, 若涉及到页面渲染的(重绘或回流), 还要等页面重新渲染后, 才会继续执行后面的代码

//    比如执行赋值操作的代码, 会先将赋值同步更新到内存中, 然后再往下执行之后的代码; 比如dom操作, 会先将操作的影响、数据等同步更新到dom树内存中, 并渲染更新完页面后, 然后再往下执行之后的代码; dom中的获取性操作, 会先将值获取到, 然后再往下执行之后的代码  ...  等其他
// js中，改改在dom树上的标签节点，即改变在dom树上dom元素的样式渲染模式,及html结构或其他所有等,只要影响页面的布局排列渲染或元素(标签)的渲染，都会触发对应的回流和重绘
// 对于隐藏的元素display: none,不会被渲染到页面上,所以修改隐藏的元素,不会触发重绘和回流，除非隐藏的元素显示了,就会触发重绘和回流

</script>
</body>
</html>
