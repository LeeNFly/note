<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <style>
    div{
      width: 100px;
      height: 100px;
      background-color: red;
    }
  </style>
</head>
<body>
  <div id="box"></div>
  <script>
    //需求: 点击div,alert一句话
    //1. 获取div
    var box = document.getElementById('box');
    //2. 注册事件
//    box.onclick = function(){
//      alert('box被点击了');
//    }
    
//    注册事件的语法: 元素.on + 事件名(此处不需要驼峰) = 函数 (引用地址);
//    给元素注册事件 (给标签注册事件)
//    这里函数使用匿名函数,参数可有可无 , 在声明/赋值/注册 时不会执行函数体 (注册事件时事件处理函数只是函数的声明,不会执行), 也不会去具体解析函数体,而是直接跳过,只有在触发事件触发时,才会调用函数,才去具体解析函数体,函数体中各个变量的值以解析函数体的时候为准,即以事件触发时/函数调用时/执行函数体时 为准
//    click : 点击事件,必须鼠标点击(左击)元素(事件源) 才会触发事件,从而调用事件处理函数,执行函数体
//    ★ 只要注册事件的代码执行成功后,该元素就完成了事件的绑定(注册),就存在于内存中了,以后只要事件被触发,就会调用执行事件处理函数
//    事件的三要素:
//    事件源  : 给谁注册事件,谁就是事件源 => 事件源是一个元素
//    事件名  : 要注册什么事件,那个事件名就是什么  点击事件的事件名是: click
//    事件处理函数 : 注册事件中, 把函数又称为事件处理函数, 这里仅仅只是函数的声明, 不会执行函数体, 要等到事件触发的时候才会被调用的函数,然后执行函数体  , 在声明/赋值/注册 时不会执行函数体, 而是直接跳过 (注册事件时事件处理函数只是函数的声明,不会执行,)只有在事件触发时,才会调用事件处理函数,执行函数体,才去具体解析函数体,函数体中各个变量的值以解析函数体的时候为准,即以事件触发时/函数调用时/执行函数体时 为准
//             ps: 1) 事件处理函数要等到对应事件触发的时候, 才会被调用, 然后执行函数体. 
//                 2) 一个事件可以被触发多次, 每次触发事件, 都会调用 一次 对应事件的事件处理函数
//                 3) 只要是触发了对应的事件, 都会调用对应事件的事件处理函数
//    事件处理函数执行完毕后,数据不会消失,而是继续存储在对应内存中,对于相同作用域内声明同名的变量,后声明的变量会把之前声明的变量覆盖

//    注意: 事件处理函数,相当于函数的声明,JS遇到时不会解析和执行里面的函数体中的代码,而是直接跳过,等到事件被触发的时候,才会调用函数,才会去具体解析和执行函数体,函数体中各个变量的值以解析函数体的时候为准,即以事件触发时/函数调用时/执行函数体时 为准
//    注意: 伪数组不能注册事件,元素才可以注册事件,需要把伪数组中的元素 一个个拿出来 才可以注册事件  
//    注意: 事件处理函数中的this: this是一个元素,解析this: 当前执行的事件处理函数是哪个元素注册的,this就是这个元素;若多个元素注册同一个事件处理函数,可以使用this将他们区分开来
//    注意: 所以如果多个元素绑定同一个事件处理函数,在执行事件处理函数的时候,this代表的是当前触发事件的那个元素,即每个元素执行事件函数时的this都是不同的,这样可以将每个元素给区分开来.
//    注意: 1个元素可以同时注册多种类型的事件 : 事件名相同,就是同类型事件; 事件名不同,就是不同类型事件
//    注意: 一个事件可以被触发多次, 每次触发都会调用执行事件处理函数,执行事件处理函数的函数体,拿到的数据都是最新的


//  事件绑定方式2:
    var box = document.getElementById('box');

    box.onclick = fn; //不要加小括号,因为加了小括号就是函数调用,会把函数执行完的结果赋值给onclick. 而我们需要的是把函数赋值给onclick (函数引用地址)

    function fn(){
      
      //如果没有加return ,浏览器会自动帮我们加一个return undefined
    }

    // 外提的事件处理函数也可以加形参e来接收事件对象
    
    // fn : 事件处理函数
    // 适合多个元素绑定逻辑相同事件处理函数,可以使用this,将每个事件源(元素)区分开来, 有利于节省内存空间
    
    // 如果要用调用元素的事件处理函数 => 元素.on + 事件名() 如：元素.onclick() 调用点击事件的事件处理函数;  => 只能调用 用 元素.on + 事件名 = 事件处理函数 注册的事件 的事件处理函数
    // 元素是对象,on+事件名可以看作给对象赋值了一个函数属性,然后我们直接调用对象的函数属性, 也会执行函数体, 相当于我们直接执行了事件处理函数
    // ★ 仅仅只是调用事件处理函数, 不会产生事件流 和 事件冒泡

    // 用js代码触发元素的事件, 元素.事件名() 如：元素.click() 用js代码触发点击事件; 可以触发元素的对应事件,调用元素对应事件的事件处理函数,执行函数体 (事件注册方式任意)
    // 与元素.onclick()不同, 元素.事件名() 是触发元素对应的事件, 会产生事件流 和 事件冒泡
    // 隐藏的页面标签, 如display: none, dom树也能获取到, 并且也能手动触发事件
  </script>
</body>
</html>