<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<style>
		div {
			width: 200px;
			height: 200px;
			background-color: pink;
			position: relative;
		}
	</style>
</head>
<body>

	<div>我是盒子</div>
	<button>点击按钮</button>
	<script>
		var div = document.querySelector("div");
		var button = document.querySelector("button");

		// 请分析: 效果是什么? 为什么 ?
		// 原来宽高 200 200
		// (1) 宽高都慢慢的变成 400
		// (2) 高瞬间变成 400px, 宽慢慢变成400px


		// 聪明的浏览器:
		// 浏览器会维护一个队列, 浏览器并不会立即进行渲染操作(回流或重绘)
		// 将所有的css 样式设置性操作, 节点设置性操作, 放到队列中, 等 js 执行完后, 再一次性进行渲染(回流和重绘), （一次性渲染时, css渲染是无序的, 同时渲染)

		// 特例: 对于一些获取性操作, 为了保证获取的数值的准确性, 会暂时停止js代码执行, 提前 flush(清空) 浏览器维护的队列,
		// 		将其解析渲染 (提前进行回流或重绘), 渲染结束后, ★★★ 再执行前面的获取性的操作, 保证获取的数值的准确性, 以及接着往下执行js代码
		// ps: 包括获取dom元素, jq对象等操作, 为了保证获取能时刻获取到元素, 会暂时停止js代码执行, 提前 flush(清空) 浏览器维护的队列,
		// 		将其解析渲染 (提前进行回流或重绘), 渲染结束后, ★★★ 再执行前面的获取性的操作, 保证能时刻获取到最新的dom元素, 以及接着往下执行js代码

		button.onclick = function() {
			// 高瞬间变400, 宽度慢慢变400
			div.style.height = "400px";
			div.offsetHeight;
			div.style.transition = "all 1s";
			div.style.width = "400px";
		}

		// button.onclick = function() {
		//  宽高都慢慢变400
		// 	div.style.height = "400px";
		// 	div.style.transition = "all 1s";
		// 	div.style.width = "400px";
		// }


		// 概念:
		// 1. 什么时候发生回流(重排) reflow:
		//    页面中的元素 只要发生影响 ★ 盒子布局、影响盒子尺寸的变化(改变宽高尺寸, padding, border, margin, 改变盒子的内容, 修改显示隐藏状态, 改变页面html节点结构, 改变dom树节点结构, 脱标, 改变class涉及到布局样式的 等等)
		//    页面需要重新布局, 就自动会触发一次回流, 整个页面会自动重新进行布局渲染 , 然后展示 (包括html, css 等都会重新渲染并展示)

		// 2. 什么时候触发重绘 repaint:
		//    页面中的元素 发生 ★ 不影响布局的 样式变化 (背景颜色, 背景图片, 字体颜色等, 改变class涉及到样式(非布局样式) ... );
		//    页面需要重新渲染, 就会自动触发一次重绘, 整个页面会自动重新进行渲染 , 然后展示 (包括html, css 等都会重新渲染并展示)

		// 重绘和回流都是一瞬间就完成的, 在我们看来就是浏览器无缝渲染

		// js中改变在dom树上的dom元素的样式(元素的样式), 或改变在dom树上的dom元素的html节点结构, 改变标签的内容, 改变盒子的显示与隐藏, 改变dom树节点结构, 或改变class涉及到css样式, 或脱标 等 的相关操作 都会触发对应的回流或重绘, 页面重新渲染和展示 (包括html, css 等都会重新渲染并展示)
		// js中, 改变在dom树上的标签节点, 即改变在dom树上dom元素的样式, 渲染模式, 及html结构或其他所有等, 只要影响页面布局排列渲染或元素(标签)的渲染, 都会触发对应的回流和重绘 页面重新渲染和展示 (包括html, css 等都会重新渲染并展示)
		// 只有在dom树上的节点, 才会被渲染到页面上, 不在dom树上的节点, 不会渲染到页面上
		// 对于隐藏的元素display:none, 由于不会被渲染到页面上, 所以修改隐藏的元素, 不会触发重绘和回流, 除非隐藏的元素显示了, 就会触发重绘和回流
		// 要点:
		// 1. 每个页面至少进行一次 回流 和 重绘 (第一次进入页面, 浏览器会进行页面的回流和重绘 渲染页面)
		// 2. ★ 回流 必将触发 重绘


		// 问题: 每次改变页面的样式, 都要触发一次回流或重绘, 那浏览器不是要崩溃了?
		// 解决: 聪明的浏览器, 浏览器的渲染优化机制

		// js执行主线程 和 UI 渲染进程 是 互斥的
		// 	同时只能执行一个, 执行js的时候, 不能进行渲染操作(回流和重绘), 执行回流和重绘的时候, 不能执行js
		//  确保js获取到的css样式是实时且准确的

		// 聪明的浏览器:
		// 浏览器会维护一个队列, 浏览器并不会立即进行渲染操作(回流或重绘)
		// 将所有的css 样式设置性操作, 节点设置性操作, class设置性操作 放到队列中, 等 所有 js 执行完, 再一次性进行渲染(回流或重绘), 只执行一次回流和重绘    (js执行主线程 和 UI 渲染进程 是 互斥的)

		// 特例: 对于一些获取性操作, 为了保证获取的数值的准确性, 会暂时停止js代码执行, 会提前 flush(清空) 浏览器维护的队列,
		// 		将其解析渲染 (提前进行回流或重绘), 渲染结束后, ★★★ 再执行前面的获取性的操作, 保证获取的数值的准确性, 以及接着往下执行js代码


		// 性能优化注意点:
		// 1. 尽量不要在 for 循环中, 进行样式获取性操作
		// 2. 通过添加 class, 来进行一次性修改样式, 少用 style (改变class如果涉及到css样式的, 会触发回流或重绘, 通过添加类, 来一次性触发回流和重绘)
		// 3. 将需要大量进行重排(回流)操作的元素, 进行display:none; 离线处理,
		// 		修改display: none的元素的样式, 页面结构, class等, 不会触发回流和重绘,
		// 		隐藏的元素不在渲染树上, 不在渲染树上的元素, 不会触发重绘和回流
		//		只会在display: none时, 触发一次回流重绘, 在display: 显示时, 触发一次回流重绘, 这样一共就触发2次回流重绘, 提高性能
		// 4. 定位(absolute和fixed)的元素, 脱标了, 不会影响的其他标准流盒子的布局, 只是回流定位流布局, 大大提高了回流和重绘效率
		// 5. 使用 translate 代替 left/top 等, translate 只触发了 重绘, 不会触发回流, 节约一次回流的时间
		//	 	 translate只是显示效果, 不会改变盒子在标准流中的位置, 不会触发回流
		//		 left 和 top 会改变元素在定位流中的位置, 会触发定位流的回流
		// 6. 通过 opacity 替换 visibility, 改透明度渲染效率更高

		// 雅虎性能优化



		// 浏览器工作原理说明:
		// 浏览器会对html, css 代码进行解析和渲染, 对js代码进行解析和执行
		// 浏览器对页面的解析和执行的顺序是从上往下解析和执行的, 包括html, css, js等其他
		// 1. dom树,规则树,以及渲染树,都是加载存储在内存中的
		// 2. js对dom树, css规则树以及渲染树的操作,比如改变dom树htm结构,或者改变dom树上dom元素(标签节点)的样式或html结构等所其他操作都会同步保存在内存中, 除非页面重新加载(刷新页面或跳转页面)
		// 3. js中声明的变量，函数,以及其他所有数据,都是一直存储在内存中的，对数据的操作,比如赋值等所有其他操作，都会一直保存在内存中,除页面重新加载(刷新页面或跳转页面)
		// 4、js中所有声明的数据(变量, 5基本, 3复杂等所有数据), 都是一次声明, 多次使用的
		// 5、js中,所有访问/使用/操作/获取性等所有操作,获取的都是访问/使用/操作/获取当前执行获取性操作这段代码时，内存中此刻保存的对应的要获取的那个数据的值
		// 6、js中,所有的代码执行都是 立即 同步 生效的, 会先立刻把代码执行的影响立刻 同步 保存在内存里, 之后再往下执行下一行代码 ... , 后面执行的代码都是基于之前执行的代码
		//    比如执行赋值操作的代码, 会先将赋值同步更新到内存中, 然后再往下执行之后的代码; 比如dom操作, 会先将操作的影响、数据等同步更新到dom树内存中, 然后再往下执行之后的代码 ... 等其他
		// 7. js中, 只要没有说是异步的, 则都是 ★ 同步执行的, 即要等到上面的代码执行完毕后且★代码执行的影响保存更新到内存, 若涉及到页面渲染的, 还要等页面重新渲染后, 才会继续执行后面的代码

		// js中，改改在dom树上的标签节点，即改变在dom树上dom元素的样式渲染模式,及html结构或其他所有等,只要影响页面的布局排列渲染或元素(标签)的渲染，都会触发对应的回流和重绘
		// 对于隐藏的元素display: none,不会被渲染到页面上,所以修改隐藏的元素,不会触发重绘和回流，除非隐藏的元素显示了,就会触发重绘和回流
	</script>
</body>
</html>
